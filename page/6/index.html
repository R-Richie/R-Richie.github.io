
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>演练场</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="R_Richie">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="演练场">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="演练场">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="演练场">

    
    <link rel="alternative" href="/atom.xml" title="演练场" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="演练场" title="演练场"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="演练场">演练场</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/05/26/arts-2019-05-26-algorithm/" title="39. 组合总和" itemprop="url">39. 组合总和</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-05-26T08:51:00.000Z" itemprop="datePublished"> Published 2019-05-26</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。<br>candidates 中的数字可以无限制重复被选取。<br>说明：</p>
<ul>
<li>所有数字（包括 target）都是正整数。</li>
<li>解集不能包含重复的组合。<br>示例 1:<br>输入: candidates = [2,3,6,7], target = 7,<br>所求解集为:<br>[<br>[7],<br>[2,2,3]<br>]<br>示例 2:<br>输入: candidates = [2,3,5], target = 8,<br>所求解集为:<br>[<br>[2,2,2,2],<br>[2,3,3],<br>[3,5]<br>]</li>
</ul>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>关键是结束条件，每次遍历target-candidates[I]，传入下一个递归，如何等于0 ，结束，如果小于最小值也结束<br>深度遍历，可以重复，如果返回，则删除最后一位添加的，继续下一个的计算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List list;</span><br><span class="line">    List item;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line">        list = new ArrayList&lt;&gt;();</span><br><span class="line">        item = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        if(candidates == null || candidates.length == 0)&#123;</span><br><span class="line">            return list;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backTracing(0,candidates,target);      </span><br><span class="line">        return list;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    private void backTracing(int index ,int[] candidates , int target)&#123;</span><br><span class="line">        if(target == 0)&#123;</span><br><span class="line">            list.add(new ArrayList&lt;&gt;(item));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(target &lt; candidates[0])&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i = index ; i&lt; candidates.length ; i++)&#123;</span><br><span class="line">            int targetDelete = target - candidates[i];</span><br><span class="line">            item.add(candidates[i]);</span><br><span class="line">            backTracing(i, candidates, targetDelete);</span><br><span class="line">            item.remove(item.size()-1);</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/leetcode/">leetcode</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/算法/">算法</a><a href="/tags/回溯思维/">回溯思维</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/05/26/arts-2019-05-26-tip/" title="线程池-ThreadPoolExecutor初探1" itemprop="url">线程池-ThreadPoolExecutor初探1</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-05-26T07:44:00.000Z" itemprop="datePublished"> Published 2019-05-26</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>基于生产者-消费者模型的线程的池化处理，重复利用已经创建的线程，减少资源的耗费。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial</span><br><span class="line"> * parameters.</span><br><span class="line"> *</span><br><span class="line"> * @param corePoolSize the number of threads to keep in the pool, even</span><br><span class="line"> *        if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set</span><br><span class="line"> * @param maximumPoolSize the maximum number of threads to allow in the</span><br><span class="line"> *        pool</span><br><span class="line"> * @param keepAliveTime when the number of threads is greater than</span><br><span class="line"> *        the core, this is the maximum time that excess idle threads</span><br><span class="line"> *        will wait for new tasks before terminating.</span><br><span class="line"> * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument</span><br><span class="line"> * @param workQueue the queue to use for holding tasks before they are</span><br><span class="line"> *        executed.  This queue will hold only the &#123;@code Runnable&#125;</span><br><span class="line"> *        tasks submitted by the &#123;@code execute&#125; method.</span><br><span class="line"> * @param threadFactory the factory to use when the executor</span><br><span class="line"> *        creates a new thread</span><br><span class="line"> * @param handler the handler to use when execution is blocked</span><br><span class="line"> *        because the thread bounds and queue capacities are reached</span><br><span class="line"> * @throws IllegalArgumentException if one of the following holds:</span><br><span class="line"> *         &#123;@code corePoolSize &lt; 0&#125;</span><br><span class="line"> *         &#123;@code keepAliveTime &lt; 0&#125;</span><br><span class="line"> *         &#123;@code maximumPoolSize &lt;= 0&#125;</span><br><span class="line"> *         &#123;@code maximumPoolSize &lt; corePoolSize&#125;</span><br><span class="line"> * @throws NullPointerException if &#123;@code workQueue&#125;</span><br><span class="line"> *         or &#123;@code threadFactory&#125; or &#123;@code handler&#125; is null</span><br><span class="line"> */</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler) &#123;</span><br><span class="line">    if (corePoolSize &lt; 0 ||</span><br><span class="line">        maximumPoolSize &lt;= 0 ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    if (workQueue == null || threadFactory == null || handler == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    this.corePoolSize = corePoolSize;</span><br><span class="line">    this.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    this.workQueue = workQueue;</span><br><span class="line">    this.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    this.threadFactory = threadFactory;</span><br><span class="line">    this.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造器有6个参数，corePoolSize是核心线程数，maximumPoolSize是最大线程数，keepAliveTime是空闲线程保持时间，unit保持时间单位，workQueue是排队队列，threadFactory自定义创建线程工厂，handler拒绝策略。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line">private static final int COUNT_BITS = Integer.SIZE - 3;</span><br><span class="line">private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;</span><br><span class="line"></span><br><span class="line">// runState is stored in the high-order bits</span><br><span class="line">private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int STOP       =  1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure></p>
<p>ctl是 线程池允许状态和线程数组合，前3位是状态，后29位是线程数，用一个原子变量表示。</p>
<p>主要的方法，执行线程方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">        if (command == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        /*</span><br><span class="line">         * Proceed in 3 steps:</span><br><span class="line">         *</span><br><span class="line">         * 1. If fewer than corePoolSize threads are running, try to</span><br><span class="line">         * start a new thread with the given command as its first</span><br><span class="line">         * task.  The call to addWorker atomically checks runState and</span><br><span class="line">         * workerCount, and so prevents false alarms that would add</span><br><span class="line">         * threads when it shouldn&apos;t, by returning false.</span><br><span class="line">         *</span><br><span class="line">         * 2. If a task can be successfully queued, then we still need</span><br><span class="line">         * to double-check whether we should have added a thread</span><br><span class="line">         * (because existing ones died since last checking) or that</span><br><span class="line">         * the pool shut down since entry into this method. So we</span><br><span class="line">         * recheck state and if necessary roll back the enqueuing if</span><br><span class="line">         * stopped, or start a new thread if there are none.</span><br><span class="line">         *</span><br><span class="line">         * 3. If we cannot queue task, then we try to add a new</span><br><span class="line">         * thread.  If it fails, we know we are shut down or saturated</span><br><span class="line">         * and so reject the task.</span><br><span class="line">         */</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            if (addWorker(command, true))</span><br><span class="line">                return;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line"> if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            int recheck = ctl.get();</span><br><span class="line">            if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            else if (workerCountOf(recheck) == 0)</span><br><span class="line">                addWorker(null, false);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (!addWorker(command, false))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>execute方法，提交runnable接口的对象<br>主要3种处理方式，<br>1.线程池的运行线程小于corePoolSize，运行addWorker添加新的线程<br>2.如果大于corePoolSize，同时线程池还在运行，就添加到工作队列里，添加成功后还要检查状态。如果线程池不允许了，就拒绝任务。如果运行线程等于0了，就新建执行任务线程。<br>3.如果线程池添加队列失败，就添加线程直到最大线程数，去执行任务。如果无法新建线程就拒绝任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">    retry:</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        int rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        // Check if queue empty only if necessary.</span><br><span class="line">        if (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == null &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int wc = workerCountOf(c);</span><br><span class="line">            if (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                return false;</span><br><span class="line">            if (compareAndIncrementWorkerCount(c))</span><br><span class="line">                break retry;</span><br><span class="line">            c = ctl.get();  // Re-read ctl</span><br><span class="line">            if (runStateOf(c) != rs)</span><br><span class="line">                continue retry;</span><br><span class="line">            // else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> boolean workerStarted = false;</span><br><span class="line">    boolean workerAdded = false;</span><br><span class="line">    Worker w = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        w = new Worker(firstTask);</span><br><span class="line">        final Thread t = w.thread;</span><br><span class="line">        if (t != null) &#123;</span><br><span class="line">            final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                // Recheck while holding lock.</span><br><span class="line">                // Back out on ThreadFactory failure or if</span><br><span class="line">                // shut down before lock acquired.</span><br><span class="line">                int rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                if (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</span><br><span class="line">                    if (t.isAlive()) // precheck that t is startable</span><br><span class="line">                        throw new IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    int s = workers.size();</span><br><span class="line">                    if (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            if (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    return workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>addWorker方法，用于添加线程，先是一个不断自旋去工作线程数，修改ctl。通过core 参数，判断是与corePoolSize 还是maximumPoolSize去判断大小，一个是是否达到核心线程数，一个是否达到最大线程数。<br>修改状态完成后，通过break label退出无限循环。<br>后面是新建worker内部类，将新建的worker添加到workers里，一个hashset，里面包含所有的只要执行的worker，worker只有获取了mainLock锁才能访问。<br>最后启动线程执行start方法，会运行worker里的run方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    runWorker(this);</span><br><span class="line">&#125;</span><br><span class="line">final void runWorker(Worker w) &#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = null;</span><br><span class="line">    w.unlock(); // allow interrupts</span><br><span class="line">    boolean completedAbruptly = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        while (task != null || (task = getTask()) != null) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            // If pool is stopping, ensure thread is interrupted;</span><br><span class="line">            // if not, ensure thread is not interrupted.  This</span><br><span class="line">            // requires a recheck in second case to deal with</span><br><span class="line">            // shutdownNow race while clearing interrupt</span><br><span class="line">            if ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            try &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; catch (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Error x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Throwable x) &#123;</span><br><span class="line">                    thrown = x; throw new Error(x);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                task = null;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> completedAbruptly = false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>run方法执行runWorker方法，将自身传入。<br>getTask从阻塞队列里获取任务，后面就是执行task里的run方法执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private Runnable getTask() &#123;</span><br><span class="line">    boolean timedOut = false; // Did the last poll() time out?</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        int rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        // Check if queue empty only if necessary.</span><br><span class="line">        if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        // Are workers subject to culling?</span><br><span class="line">        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;</span><br><span class="line">            if (compareAndDecrementWorkerCount(c))</span><br><span class="line">                return null;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"> try &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            if (r != null)</span><br><span class="line">                return r;</span><br><span class="line">            timedOut = true;</span><br><span class="line">        &#125; catch (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不断自旋判断，如果线程池停止或者队列为空就减少工作线程数。<br>获取线程有2种情况，timed是allowCoreThreadTimeOut 和工作线程是否大于核心线程来决定。<br>2种情况，1种所有线程都记录空闲时间，1种是只有超过核心线程记录空闲时间。<br>这两种情况使用poll方法，如果队列为空就阻塞keepAliveTime时间，就返回。<br>如果不是这两种情况，就直接take如果阻塞就直接报错，然后重新循环。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/后端/">后端</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/java/">java</a><a href="/tags/编程技巧/">编程技巧</a><a href="/tags/并发集合/">并发集合</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/05/26/arts-2019-05-26-share/" title="《7up》第二遍观后感5" itemprop="url">《7up》第二遍观后感5</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-05-26T07:41:01.000Z" itemprop="datePublished"> Published 2019-05-26</time>
    
  </p>
</header>
    <div class="article-content">
        
        <ol>
<li><p>拥有更长时间的思维，5-10年，放长视野，顺利的人生不多，最重要的能力是从失败中重新站起来。人生也是，长达50-70年，一小段时间的低迷，每个人都会经历，越早站起来，越能奔向下一个高峰。抗挫折能力很重要，地图很重要，看清周期，看清规律。</p>
</li>
<li><p>自我剖析是痛苦的，看见，承认自己的缺点是痛苦，人心里都有对自己的一个美好幻想。认清自己很困难，需要从第三视角去旁观。</p>
</li>
<li><p>要抬头看宏观世界的运行周期，人顺应时代更能快速发展，逆规律艰难求生，经济危机下人人都不好找工作</p>
</li>
<li><p>多领域参与很重要，单一行业总有周期</p>
</li>
<li><p>经营家庭是给人幸福感提升的方式，一个社会的小单位，共同度过难关，互相扶持</p>
</li>
<li><p>越帮助别人越快乐，能力越大，越付出帮助社会。</p>
</li>
<li>修身齐家平天下，顺序不可颠倒。</li>
</ol>
<p>思维模式：长期思维，周期思维，抗挫折，地图，不变特性</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/人文/">人文</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/感悟/">感悟</a><a href="/tags/纪录片/">纪录片</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/05/18/arts-2019-05-18-algorithm2/" title="211.添加与搜索单词 - 数据结构设计" itemprop="url">211.添加与搜索单词 - 数据结构设计</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-05-18T14:18:07.000Z" itemprop="datePublished"> Published 2019-05-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>设计一个支持以下两种操作的数据结构：<br>void addWord(word)<br>bool search(word)<br>search(word) 可以搜索文字或正则表达式字符串，字符串只包含字母 . 或 a-z 。 . 可以表示任何一个字母。<br>示例:<br>addWord(“bad”)<br>addWord(“dad”)<br>addWord(“mad”)<br>search(“pad”) -&gt; false<br>search(“bad”) -&gt; true<br>search(“.ad”) -&gt; true<br>search(“b..”) -&gt; true<br>说明:<br>你可以假设所有单词都是由小写字母 a-z 组成的。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>用字典树可以解决，关键问题是.如何解决<br>我第一时间想到递归，遇到。要遍历整个子字符数组，<br>有一个递归标志符，表示已经匹配，这个标志符成功则返回，写的很乱，自己都懵逼<br>如何是. 就深度遍历，如果不是就匹配<br>结束条件，不匹配或到结尾，最后匹配是不是有结束符号<br>分两个2情况，一种是。，深度遍历，一种是具体值，走字典树<br>递归结束时index到数组结尾，返回结束标示符，需要空数组也返回false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">class WordDictionary &#123;</span><br><span class="line">    private TreeNode root;</span><br><span class="line">    public static class TreeNode&#123;</span><br><span class="line">        private char data;</span><br><span class="line">        private TreeNode[] child = new TreeNode[26];</span><br><span class="line">        private boolean isEndingChar = false;</span><br><span class="line">        public TreeNode(char data)&#123;</span><br><span class="line">            this.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">    public WordDictionary() &#123;</span><br><span class="line">        root = new TreeNode(&apos;/&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Adds a word into the data structure. */</span><br><span class="line">    public void addWord(String word) &#123;</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        char[] array = word.toCharArray();</span><br><span class="line">        for(int i = 0 ;i &lt; array.length ; i++)&#123;</span><br><span class="line">            int index = array[i] - &apos;a&apos;;</span><br><span class="line">            if(node.child[index] == null)&#123;</span><br><span class="line">                node.child[index] = new TreeNode(array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.child[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEndingChar = true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Returns if the word is in the data structure. A word could contain the dot character &apos;.&apos; to represent any one letter. */</span><br><span class="line">    public boolean search(String word) &#123;</span><br><span class="line">        if(word == null || word.length() == 0)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        char[] array = word.toCharArray();</span><br><span class="line">        return helper(array,0,node);       </span><br><span class="line">    &#125;</span><br><span class="line">    public boolean helper(char[] array,int index,TreeNode node)&#123;</span><br><span class="line">        if(index == array.length)&#123;</span><br><span class="line">            return node.isEndingChar;</span><br><span class="line">        &#125;        </span><br><span class="line">        char data = array[index];</span><br><span class="line">        </span><br><span class="line">        if(data == &apos;.&apos;)&#123; </span><br><span class="line">            TreeNode[] child = node.child;          </span><br><span class="line">            for(int i = 0 ; i&lt; child.length ; i++)&#123;</span><br><span class="line">                </span><br><span class="line">                if(child[i] != null &amp;&amp; helper(array, index+1, child[i]))&#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            int num = data - &apos;a&apos;;</span><br><span class="line">            if(node.child[num] == null)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;           </span><br><span class="line">            return helper(array,index+1, node.child[num]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your WordDictionary object will be instantiated and called as such:</span><br><span class="line"> * WordDictionary obj = new WordDictionary();</span><br><span class="line"> * obj.addWord(word);</span><br><span class="line"> * boolean param_2 = obj.search(word);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/leetcode/">leetcode</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/算法/">算法</a><a href="/tags/Trie树/">Trie树</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/05/18/arts-2019-05-18-tip2/" title="Java并发集合-LinkedBlockingQueue" itemprop="url">Java并发集合-LinkedBlockingQueue</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-05-18T14:18:00.000Z" itemprop="datePublished"> Published 2019-05-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>基于链表的有界阻塞队列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Linked list node class</span><br><span class="line"> */</span><br><span class="line">static class Node&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * One of:</span><br><span class="line">     * - the real successor Node</span><br><span class="line">     * - this Node, meaning the successor is head.next</span><br><span class="line">     * - null, meaning there is no successor (this is the last node)</span><br><span class="line">     */</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(E x) &#123; item = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于单链表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/** The capacity bound, or Integer.MAX_VALUE if none */</span><br><span class="line">private final int capacity;</span><br><span class="line"></span><br><span class="line">/** Current number of elements */</span><br><span class="line">private final AtomicInteger count = new AtomicInteger();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Head of linked list.</span><br><span class="line"> * Invariant: head.item == null</span><br><span class="line"> */</span><br><span class="line">transient Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Tail of linked list.</span><br><span class="line"> * Invariant: last.next == null</span><br><span class="line"> */</span><br><span class="line">private transient Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">/** Lock held by take, poll, etc */</span><br><span class="line">private final ReentrantLock takeLock = new ReentrantLock();</span><br><span class="line">/** Wait queue for waiting takes */</span><br><span class="line">private final Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">/** Lock held by put, offer, etc */</span><br><span class="line">private final ReentrantLock putLock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">/** Wait queue for waiting puts */</span><br><span class="line">private final Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure>
<p>capacity是用于记录容量 ，首尾两个指针，head和last。基于2个锁，一个takeLock锁，notEmpty条件变量，在空时候用。一个putLock锁，notFull条件变量，在满的时候用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Creates a &#123;@code LinkedBlockingQueue&#125; with a capacity of</span><br><span class="line"> * &#123;@link Integer#MAX_VALUE&#125;.</span><br><span class="line"> */</span><br><span class="line">public LinkedBlockingQueue() &#123;</span><br><span class="line">    this(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Creates a &#123;@code LinkedBlockingQueue&#125; with the given (fixed) capacity.</span><br><span class="line"> *</span><br><span class="line"> * @param capacity the capacity of this queue</span><br><span class="line"> * @throws IllegalArgumentException if &#123;@code capacity&#125; is not greater</span><br><span class="line"> *         than zero</span><br><span class="line"> */</span><br><span class="line">public LinkedBlockingQueue(int capacity) &#123;</span><br><span class="line">    if (capacity &lt;= 0) throw new IllegalArgumentException();</span><br><span class="line">    this.capacity = capacity;</span><br><span class="line">    last = head = new Node&lt;E&gt;(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化可以赋值容量，新建哨兵头指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Inserts the specified element at the tail of this queue, waiting if</span><br><span class="line"> * necessary for space to become available.</span><br><span class="line"> *</span><br><span class="line"> * @throws InterruptedException &#123;@inheritDoc&#125;</span><br><span class="line"> * @throws NullPointerException &#123;@inheritDoc&#125;</span><br><span class="line"> */</span><br><span class="line">public void put(E e) throws InterruptedException &#123;</span><br><span class="line">    if (e == null) throw new NullPointerException();</span><br><span class="line">    // Note: convention in all put/take/etc is to preset local var</span><br><span class="line">    // holding count negative to indicate failure unless set.</span><br><span class="line">    int c = -1;</span><br><span class="line">    Node&lt;E&gt; node = new Node&lt;E&gt;(e);</span><br><span class="line">    final ReentrantLock putLock = this.putLock;</span><br><span class="line">    final AtomicInteger count = this.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        /*</span><br><span class="line">         * Note that count is used in wait guard even though it is</span><br><span class="line">         * not protected by lock. This works because count can</span><br><span class="line">         * only decrease at this point (all other puts are shut</span><br><span class="line">         * out by lock), and we (or some other waiting put) are</span><br><span class="line">         * signalled if it ever changes from capacity. Similarly</span><br><span class="line">         * for all other uses of count in other wait guards.</span><br><span class="line">         */</span><br><span class="line">        while (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(node);</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        if (c + 1 &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    if (c == 0)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * Links node at end of queue.</span><br><span class="line"> *</span><br><span class="line"> * @param node the node</span><br><span class="line"> */</span><br><span class="line">private void enqueue(Node&lt;E&gt; node) &#123;</span><br><span class="line">    // assert putLock.isHeldByCurrentThread();</span><br><span class="line">    // assert last.next == null;</span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果队列容量等于最大容量，线程要在notFull 条件变量下等待。<br>如果没满，就调用enqueue，进行入站。<br>如果添加队列后小于容量，就在notFull里唤醒一个线程。<br>这里面使用putLock进行加锁，不影响出站。<br>由于是2个锁，只有在容量空的时候，才会去唤醒takeLock的notEmpty等待队列。<br>使用的模型与一个锁的不同，2个锁的模型，需要通过原子操作的count来判断是不是唤醒，小于容量就可以唤醒notFull等待队列，最后如果容量等于0，就去takeLock的锁去唤醒notEmpty等待队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">    E x;</span><br><span class="line">    int c = -1;</span><br><span class="line">    final AtomicInteger count = this.count;</span><br><span class="line">    final ReentrantLock takeLock = this.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (count.get() == 0) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        if (c &gt; 1)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    if (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * Removes a node from head of queue.</span><br><span class="line"> *</span><br><span class="line"> * @return the node</span><br><span class="line"> */</span><br><span class="line">private E dequeue() &#123;</span><br><span class="line">    // assert takeLock.isHeldByCurrentThread();</span><br><span class="line">    // assert head.item == null;</span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    h.next = h; // help GC</span><br><span class="line">    head = first;</span><br><span class="line">    E x = first.item;</span><br><span class="line">    first.item = null;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出队列，与入队列思路相同，使用takeLock锁，如果count为0，就进入notEmpty队列等待。<br>dequeue就是将头删除，原来的first元素，变成哨兵指针。<br>如果count 大于1还可以继续take，唤醒notEmpty队列的线程。最后如果修改之前count等于容量，唤醒notFull队列，还可以put。<br>offer和poll和put和take原理相同，只是他们不是阻塞的，直接返回布尔值。</p>
<p>总结：基于单链表的阻塞单端队列，入队出队2个独立的锁，通过原子操作count，来处理状态。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/后端/">后端</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/java/">java</a><a href="/tags/编程技巧/">编程技巧</a><a href="/tags/并发集合/">并发集合</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/05/18/arts-2019-05-18-algorithm1/" title="208.实现 Trie (前缀树)" itemprop="url">208.实现 Trie (前缀树)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-05-18T14:17:07.000Z" itemprop="datePublished"> Published 2019-05-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。<br>示例:<br>Trie trie = new Trie();<br>trie.insert(“apple”);<br>trie.search(“apple”);   // 返回 true<br>trie.search(“app”);     // 返回 false<br>trie.startsWith(“app”); // 返回 true<br>trie.insert(“app”);<br>trie.search(“app”);     // 返回 true<br>说明:<br>你可以假设所有的输入都是由小写字母 a-z 构成的。<br>保证所有输入均为非空字符串。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>开始是root不存储数据<br>然后引入一个小写字母数组<br>每个数组里面的对象包含自己和数组还有是否是叶子结点<br>内部类 TreeNode，包含字符，TreeNode数组，叶子结点标示<br>每次一个字符，一次遍历查下去<br>abcde fghij klmno pqrst uvwxy z<br>字符数组的大小一直错<br>Trie树的实现<br>插入没有就新建，有的继续遍历<br>搜索跟新建相似，最后介绍不是叶子结点就返回false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">class Trie &#123;</span><br><span class="line">    private TreeNode root;</span><br><span class="line">    public static class TreeNode&#123;</span><br><span class="line">        private char data;</span><br><span class="line">        private TreeNode[] child = new TreeNode[26];</span><br><span class="line">        private boolean isEndingChar = false;</span><br><span class="line">        public TreeNode(char data)&#123;</span><br><span class="line">            this.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">    public Trie() &#123;</span><br><span class="line">        root = new TreeNode(&apos;/&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Inserts a word into the trie. */</span><br><span class="line">    public void insert(String word) &#123;</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        char[] array = word.toCharArray();</span><br><span class="line">        for(int i = 0 ; i &lt; array.length ; i++)&#123;</span><br><span class="line">            int index = array[i] - &apos;a&apos;;</span><br><span class="line">            if(node.child[index] == null)&#123;</span><br><span class="line">                node.child[index] = new TreeNode(array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.child[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEndingChar = true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Returns if the word is in the trie. */</span><br><span class="line">    public boolean search(String word) &#123;</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        char[] array = word.toCharArray();</span><br><span class="line">        for(int i = 0 ; i &lt; array.length ; i++)&#123;</span><br><span class="line">            int index = array[i] - &apos;a&apos;;</span><br><span class="line">            if(node.child[index] == null)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.child[index];</span><br><span class="line">        &#125;</span><br><span class="line">        if(!node.isEndingChar)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Returns if there is any word in the trie that starts with the given prefix. */</span><br><span class="line">    public boolean startsWith(String prefix) &#123;</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        char[] array = prefix.toCharArray();</span><br><span class="line">        for(int i = 0 ; i &lt; array.length ; i++)&#123;</span><br><span class="line">            int index = array[i] - &apos;a&apos;;</span><br><span class="line">            if(node.child[index] == null)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.child[index];</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your Trie object will be instantiated and called as such:</span><br><span class="line"> * Trie obj = new Trie();</span><br><span class="line"> * obj.insert(word);</span><br><span class="line"> * boolean param_2 = obj.search(word);</span><br><span class="line"> * boolean param_3 = obj.startsWith(prefix);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/leetcode/">leetcode</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/算法/">算法</a><a href="/tags/Trie树/">Trie树</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/05/18/arts-2019-05-18-tip1/" title="Java并发集合-DelayQueue" itemprop="url">Java并发集合-DelayQueue</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-05-18T14:14:00.000Z" itemprop="datePublished"> Published 2019-05-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>基于优先级队列的无界队列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Creates a new &#123;@code DelayQueue&#125; that is initially empty.</span><br><span class="line"> */</span><br><span class="line">public DelayQueue() &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>构造器为空</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private final transient ReentrantLock lock = new ReentrantLock();</span><br><span class="line">private final PriorityQueue&lt;E&gt; q = new PriorityQueue&lt;E&gt;();</span><br><span class="line">private Thread leader = null;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Condition signalled when a newer element becomes available</span><br><span class="line"> * at the head of the queue or a new thread may need to</span><br><span class="line"> * become leader.</span><br><span class="line"> */</span><br><span class="line">private final Condition available = lock.newCondition();</span><br></pre></td></tr></table></figure>
<p>一个内部的锁，一个存储用的优先级队列，存储对象E，要继承Delayed，一个leader用于当前优先级最高要执行的线程。available用于等待的线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Inserts the specified element into this delay queue.</span><br><span class="line"> *</span><br><span class="line"> * @param e the element to add</span><br><span class="line"> * @return &#123;@code true&#125;</span><br><span class="line"> * @throws NullPointerException if the specified element is null</span><br><span class="line"> */</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        q.offer(e);</span><br><span class="line">        if (q.peek() == e) &#123;</span><br><span class="line">            leader = null;</span><br><span class="line">            available.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要的插入的方法是offer，使用lock锁住，存取使用同一个锁，将新元素添加之前的优先级队列中，如果添加的新元素根据优先级排列在第一位，就要清空原来要执行leader线程，不然你没法作为优先级最好的去执行，然后随便唤醒一个线程就可以执行优先级最高的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Retrieves and removes the head of this queue, waiting if necessary</span><br><span class="line"> * until an element with an expired delay is available on this queue.</span><br><span class="line"> *</span><br><span class="line"> * @return the head of this queue</span><br><span class="line"> * @throws InterruptedException &#123;@inheritDoc&#125;</span><br><span class="line"> */</span><br><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            E first = q.peek();</span><br><span class="line">            if (first == null)</span><br><span class="line">                available.await();</span><br><span class="line">            else &#123;</span><br><span class="line">                long delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                if (delay &lt;= 0)</span><br><span class="line">                    return q.poll();</span><br><span class="line">                first = null; // don&apos;t retain ref while waiting</span><br><span class="line">                if (leader != null)</span><br><span class="line">                    available.await();</span><br><span class="line">                else &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        if (leader == thisThread)</span><br><span class="line">                            leader = null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (leader == null &amp;&amp; q.peek() != null)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Take是获取到时间的元素，不断自旋，进来先取出优先级队列的第一个，如果优先级队列是空，就在available变量里等待。<br>如果队列里有元素，就计算纳秒的延迟时间。如果这个时间小于0，就弹出元素，然后返回，这个是推出自旋的出口。<br>如果还没到延迟时间，就看leader是不是有值，代表只不是有其他正要执行的线程，如果有就等待，如果没有，就将当前线程作为执行线程，同时等待延迟时间，到时间后唤醒，重新自旋，判断是否退出。<br>这个主要问题就是插入优先级高于正要执行的当前线程，就需要重置leader重新判断哪个实现执行。<br>最后没有leader线程再执行，就再唤醒下一个available的等待线程<br>总结：基于优先级队列，需要自己继承Delay，实现比较、计算延迟时间的方法。通过等待与唤醒来按时间执行。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/后端/">后端</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/java/">java</a><a href="/tags/编程技巧/">编程技巧</a><a href="/tags/并发集合/">并发集合</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/05/18/arts-2019-05-18-share/" title="《7up》第二遍观后感4" itemprop="url">《7up》第二遍观后感4</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-05-18T14:07:01.000Z" itemprop="datePublished"> Published 2019-05-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><strong>回望每个人的一个个七年，提取出共性，每个人大致都会经历的事情，看人的一生的规律</strong></p>
<h2 id="人生的几个阶段"><a href="#人生的几个阶段" class="headerlink" title="人生的几个阶段"></a>人生的几个阶段</h2><p>原生家庭（父母是否离婚，单亲，与父母相处的时间）<br>教育（学校（付出金钱的程度），自己学习的态度）<br>工作（获得金钱是否足够生活，是否努力向上）<br>婚姻（多大年龄结婚，如何维系婚姻，离婚，再婚）<br>子女（是否要孩子，几个孩子，如何处理关系）<br>父母（去世，癌症，关系）<br>健康（疾病，生活质量）</p>
<hr>
<p><strong>俯瞰人生，看重要阶段见元素的关联关系，分析人生的关键点</strong></p>
<h2 id="重要阶段分析"><a href="#重要阶段分析" class="headerlink" title="重要阶段分析"></a>重要阶段分析</h2><p>人从出生开始就各不相同，家庭情况对于每个新生儿来说是随机的，不能选择的。<br>富裕的家庭的孩子比贫困的更加自信。单亲或父母离婚的比正常家庭的孩子，更没有安全感，缺乏自信。<br>好的教育可以改变一个人，富裕家庭的孩子可以接受更好的教育，比如读私立学校，读预科学校。贫穷家庭的孩子可能没意识到教育的重要性，需要更早的进入社会，去竞争生存。也可能通过教育，提升自己的维度，让自己跨越不同的阶级。<br>出生情况不能选择，但后面的人生可以选择，选择的前提是自己的见识。<br>见识的高度才是整个人生的高度，先天不足可以后天弥补，但如果不知道自己不足，那就会原地踏步。听到之前林赛说，她们三姐妹反而比富人的家的孩子选择更多，他们的人生已经固定，从7岁就被选择好了，她们可以自由的决定。一听起来好像很有道理，但这个是带有偏见的，富人家的孩子也是通过不断努力才达到父母预期的高度，不能否认他们自己的努力，并非一切从出生就安排好了，而是他们努力达到的比较高的目标。反而是林赛她们没有什么目标，好像可以自由选择，但都是漫无目的的原地踏步。<br>婚姻对一个人十分重要，好的婚姻二个人互相扶持，共同面对困难，共同承担责任。很多人当时结婚的时候并没有考虑清楚，只是正好到了年龄，决定应该结婚了。一些自我牺牲，换取团体的利益最大化，在不断磨合下，既能做自己，又能融洽相处。婚姻是一个集体，家庭也是一个集体，这个集体与外面的不太一样，是通过血缘与爱结合在一起。<br>子女出生，又是一个轮回，到了教育子女的问题了，大部分会将自己的遗憾投射到子女身上，希望她们比自己更好，不经历自己的痛苦，希望自己的孩子接受更好的教育，但也要跟自己经济实力匹配，父母一般会支出一条自己熟悉的路。<br>健康是无价之宝，一切的前提，得癌症的概率很高，没有几个健康的身体，生活的质量会明显下降。<br>死亡是每个人都必须面对的，父母、亲人的离世，自己的寿命到期，尽量多帮助别人，可以在多留下自己的生活过的痕迹。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/人文/">人文</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/感悟/">感悟</a><a href="/tags/纪录片/">纪录片</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/05/12/arts-2019-05-12-review/" title="Distributed Systems Principles and Paradigms 学习笔记2" itemprop="url">Distributed Systems Principles and Paradigms 学习笔记2</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-05-12T09:22:07.000Z" itemprop="datePublished"> Published 2019-05-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>这周读的也不多，只读了一节</p>
<p>第二节讲了分布式的架构，在谈论架构时，一个关键的想法是架构风格。 一种风格反映了组织包括分布式系统的软件组件之间的交互所遵循的基本原则。 重要的样式包括分层，面向对象，面向事件和数据中心方向。</p>
<p>分布式有很多组织结构，一种重要的模式切分服务器为访问端和服务器端。</p>
<p>客户端 - 服务器架构通常高度集中。 在分散的架构中，我们经常看到构成分布式系统的过程所起的平等作用，也称为点对点系统。 在对等系统中，进程被组织成覆盖网络，该覆盖网络是逻辑网络，其中每个进程具有可与其通信的其他对等体的本地列表。 可以构造覆盖网络，在这种情况下，可以部署确定性方案以在进程之间路由消息。 在非结构化网络中，对等体列表或多或少是随机的，这意味着需要部署搜索算法来定位数据或其他进程。</p>
<p>作为替代方案，已经开发了自我管理的分布式系统。 这些系统在某种程度上融合了系统和软件架构的想法。 自我管理系统通常可以组织为反馈控制循环。 这样的循环包含由分布式系统的行为测量的监视组件，用于查看是否需要调整任何内容的分析组件，以及用于改变行为的各种仪器的集合。 反馈控制循环可以集成到许多地方的分布式系统中。 在共同理解如何开发和部署这样的循环之前，仍然需要进行大量研究。</p>
<p>总结的翻译，这周看的时间很少，还没有找到分布式的线索。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/英语原文/">英语原文</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/分布式/">分布式</a><a href="/tags/架构/">架构</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/05/12/arts-2019-05-12-share/" title="《全球科技史纲》吴军-读后感1" itemprop="url">《全球科技史纲》吴军-读后感1</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-05-12T09:18:07.000Z" itemprop="datePublished"> Published 2019-05-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>之前在得到上听了一遍，今天又重新看书。书中使用2条线索穿起来整个科技史，能量与信息，真的很绝妙。相信没有理科思维的人是不会有这两种视角去看历史。从能量的角度看人类是怎么一步步进化，是不断获取更多的能量。信息的处理又能优化能量的使用。<br>之前的历史都是使用重大事件以及它产生的意义作为分割点，但这里从能量的角度去看，既新奇又合理，之前为什么没有想到。物理学是研究事物规律的，那里面的一些定律是不是会反映出一些，客观规律，也可以作为一些基础概念，理解其他事物。<br>还是比较好奇，吴军老师是怎么研究这些历史的，现在听得都是结果，如果我想自己去做研究，要从哪里获取资料，怎么去研究，怎么得到结论。吴军老师经常能拿一些我们之前熟悉的例子，通过一些不为人知的历史，来证明原来的是谣传。如何查看的资料，我很想知道。<br>很多史料都很有趣，比如人发明衣服的时间是通过体虱的进化时间的来，人类走出非洲的时间跟太阳的热量有关。人类从史前到定居，农耕，创建文明。<br><strong>分享一些基本方法论</strong><br>回望历史，把握历史进化的来龙去脉，可以清楚我们今天所处的位置；<br>俯瞰历史，把握所有要素之间的联系，可以看清世界变化的规律。<br>经典结论<br>历史总在重演，科技永远向前。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/人文/">人文</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/感悟/">感悟</a><a href="/tags/吴军/">吴军</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/5/"><span></span>Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/7/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Java语言基础/" title="Java语言基础">Java语言基础<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Spring/" title="Spring">Spring<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/leetcode/" title="leetcode">leetcode<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/人文/" title="人文">人文<sup>28</sup></a></li>
		  
		
		  
			<li><a href="/categories/前端/" title="前端">前端<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/后端/" title="后端">后端<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/成长/" title="成长">成长<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/树莓派/" title="树莓派">树莓派<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/监控/" title="监控">监控<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/英语原文/" title="英语原文">英语原文<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/闲谈/" title="闲谈">闲谈<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/感悟/" title="感悟">感悟<sup>28</sup></a></li>
			
		
			
				<li><a href="/tags/编程技巧/" title="编程技巧">编程技巧<sup>26</sup></a></li>
			
		
			
				<li><a href="/tags/算法/" title="算法">算法<sup>24</sup></a></li>
			
		
			
				<li><a href="/tags/java/" title="java">java<sup>14</sup></a></li>
			
		
			
				<li><a href="/tags/分布式/" title="分布式">分布式<sup>12</sup></a></li>
			
		
			
				<li><a href="/tags/架构/" title="架构">架构<sup>11</sup></a></li>
			
		
			
				<li><a href="/tags/计算机组成/" title="计算机组成">计算机组成<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/纪录片/" title="纪录片">纪录片<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/电视剧/" title="电视剧">电视剧<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/链表/" title="链表">链表<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/动态规划/" title="动态规划">动态规划<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/并发集合/" title="并发集合">并发集合<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/集合/" title="集合">集合<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/字符串/" title="字符串">字符串<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/历史/" title="历史">历史<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/学习方法/" title="学习方法">学习方法<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Trie树/" title="Trie树">Trie树<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/spring-cloud/" title="spring cloud">spring cloud<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Java/" title="Java">Java<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/树/" title="树">树<sup>2</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Larry Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2019 
		
		<a href="/about" target="_blank" title="R_Richie">R_Richie</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
