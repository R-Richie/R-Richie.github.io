
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>演练场</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="R_Richie">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="演练场">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="演练场">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="演练场">

    
    <link rel="alternative" href="/atom.xml" title="演练场" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="演练场" title="演练场"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="演练场">演练场</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/05/11/arts-2019-05-12-tip/" title="java锁-CountDownLatch" itemprop="url">java锁-CountDownLatch</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-05-11T14:31:00.000Z" itemprop="datePublished"> Published 2019-05-11</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>内部类Sync继承AbstractQueuedSynchronizer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Synchronization control For CountDownLatch.</span><br><span class="line"> * Uses AQS state to represent count.</span><br><span class="line"> */</span><br><span class="line">private static final class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">    private static final long serialVersionUID = 4982264981922014374L;</span><br><span class="line"></span><br><span class="line">    Sync(int count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getCount() &#123;</span><br><span class="line">        return getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">        return (getState() == 0) ? 1 : -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">        // Decrement count; signal when transition to zero</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int c = getState();</span><br><span class="line">            if (c == 0)</span><br><span class="line">                return false;</span><br><span class="line">            int nextc = c-1;</span><br><span class="line">            if (compareAndSetState(c, nextc))</span><br><span class="line">                return nextc == 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过构造器传入state的数值。<br>tryAcquireShared 非独占加锁，实现如果state不是0，就返回-1，小于0。等于0，就返回1，大于0<br>tryReleaseShare 非独占解锁，自旋，如果状态等于0，就是解锁失败。每次解锁大小减1，如果等于0，则解锁成功，其他则失败</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public CountDownLatch(int count) &#123;</span><br><span class="line">    if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;);</span><br><span class="line">    this.sync = new Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造器传入count，赋值给state<br>添加await方法，用于加锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public void await() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line">private void doAcquireSharedInterruptibly(int arg)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    final Node node = addWaiter(Node.SHARED);</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            if (p == head) &#123;</span><br><span class="line">                int r = tryAcquireShared(arg);</span><br><span class="line">                if (r &gt;= 0) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除非state减为0，其他情况，tryAcquireShared都小于0，要进doAcquireSharedInterruptibly方法<br>doAcquireSharedInterruptibly方法，先非独占的加入队列，然后判断前序节点是不是头节点，<br>如果是前序节点是头节点，判断tryAcquireShared结果，在state减为0前，这个都是不进入r》=0的条件里，后面就会wait等待 前面执行完，后唤醒。<br>不断自旋，只有在前序是头节点，同时state是0 时，才会继续执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void countDown() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>countDown，每次减1，在每到0，之前返回都是false。</p>
<p>总结：基于模版AbstractQueuedSynchronizer，通过tryAcquireShared 加锁，countDown 不断减少state，直到等于0，再解锁，可以实现，单个线程等待其他多个线程的功能。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/后端/">后端</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/编程技巧/">编程技巧</a><a href="/tags/java/">java</a><a href="/tags/锁/">锁</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/05/05/arts-2019-05-05-review/" title="Distributed Systems Principles and Paradigms 学习笔记1" itemprop="url">Distributed Systems Principles and Paradigms 学习笔记1</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-05-05T08:22:07.000Z" itemprop="datePublished"> Published 2019-05-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>五一假期，学习时间比平时还要少，看得很少，先写一部分吧。</p>
<h2 id="分布式系统的定义"><a href="#分布式系统的定义" class="headerlink" title="分布式系统的定义"></a>分布式系统的定义</h2><p>A distributed system is a collection of independent computers that appears to its users as a single coherent system.<br>分布式系统是一堆独立的电脑的集合，使用者使用的像是单一系统一样。</p>
<h2 id="分布式系统的目标"><a href="#分布式系统的目标" class="headerlink" title="分布式系统的目标"></a>分布式系统的目标</h2><ol>
<li>Making Resources Accessible</li>
<li>Distribution Transparency</li>
<li>Openness</li>
<li>Scalability</li>
<li>Pitfalls</li>
</ol>
<p>第一个是让分散在各地的资源可以简单被访问。<br>第二个是分配透明度，隐藏资源分布在各地。<br>第三个是开放式分布式系统是根据标准规则提供服务的系统，这些规则描述了这些服务的语法和语义。<br>第四个是可扩展性<br>第五个是一些陷阱，7大分布式谬论</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/英语原文/">英语原文</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/分布式/">分布式</a><a href="/tags/架构/">架构</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/05/05/arts-2019-05-05-algorithm/" title="克隆图" itemprop="url">克隆图</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-05-05T03:42:07.000Z" itemprop="datePublished"> Published 2019-05-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定无向连通图中一个节点的引用，返回该图的深拷贝（克隆）。图中的每个节点都包含它的值&nbsp;val（Int） 和其邻居的列表（list[Node]）。<br>示例：<img src="evernotecid://BA9A3242-C386-4E68-A9D1-1193A9AF4350/appyinxiangcom/11402844/ENResource/p911" alt="7b2bfd1590ab9401ab6d2eb6d985b68a.png"><br>输入：{“$id”:”1”,”neighbors”:[{“$id”:”2”,”neighbors”:[{“$ref”:”1”},{“$id”:”3”,”neighbors”:[{“$ref”:”2”},{“$id”:”4”,”neighbors”:[{“$ref”:”3”},{“$ref”:”1”}],”val”:4}],”val”:3}],”val”:2},{“$ref”:”4”}],”val”:1}解释：节点 1 的值是 1，它有两个邻居：节点 2 和 4 。节点 2 的值是 2，它有两个邻居：节点 1 和 3 。节点 3 的值是 3，它有两个邻居：节点 2 和 4 。节点 4 的值是 4，它有两个邻居：节点 1 和 3 。提示：节点数介于 1 到 100 之间。无向图是一个简单图，这意味着图中没有重复的边，也没有自环。由于图是无向的，如果节点&nbsp;p&nbsp;是节点&nbsp;q&nbsp;的邻居，那么节点&nbsp;q&nbsp;也必须是节点&nbsp;p&nbsp;的邻居。必须将给定节点的拷贝作为对克隆图的引用返回。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>深度遍历+深浅克隆<br>Map用于存放访问过的点，如果访问过直接返回<br>递归遍历neighbors<br>结束条件是，所有节点都访问过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">// Definition for a Node.</span><br><span class="line">class Node &#123;</span><br><span class="line">    public int val;</span><br><span class="line">    public List&lt;Node&gt; neighbors;</span><br><span class="line"></span><br><span class="line">    public Node() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public Node(int _val,List&lt;Node&gt; _neighbors) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        neighbors = _neighbors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public Node cloneGraph(Node node) &#123;</span><br><span class="line">        Map&lt;Integer,Node&gt; map = new HashMap&lt;Integer,Node&gt;();</span><br><span class="line">        return deepClone(node,map);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Node deepClone(Node node,Map&lt;Integer,Node&gt; map)&#123;</span><br><span class="line">        Node newNode;</span><br><span class="line">        if(map.containsKey(node.val))&#123;</span><br><span class="line">            newNode = map.get(node.val);</span><br><span class="line">            return newNode;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            newNode = new Node(node.val,null);</span><br><span class="line">            map.put(node.val,newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Node&gt; nei = new ArrayList&lt;Node&gt;();</span><br><span class="line">        if(node.neighbors != null)&#123;</span><br><span class="line">            for(Node n : node.neighbors)&#123;</span><br><span class="line">                nei.add(deepClone(n,map));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode.neighbors = nei;</span><br><span class="line">        return newNode;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/leetcode/">leetcode</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/算法/">算法</a><a href="/tags/图/">图</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/05/05/arts-2019-05-05-share/" title="纪念高中同桌-张迪" itemprop="url">纪念高中同桌-张迪</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-05-05T02:59:07.000Z" itemprop="datePublished"> Published 2019-05-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>在我写这篇文章的时候，是五一假期，大部分人还在假期的欢乐中，或者旅游，或者休闲，但你却在跟病魔的斗争中走完人生的最后一段路，你的离去只是时间问题。死亡是每个人都必须面对的，最终的去处，但能无憾的离去，实在不容易。回顾我们一起的岁月，在我的心中，让你继续走下去。<br>    我们相识在高中，沈阳二中。经过了7中，每天不断的重复做卷子，我来到了二中，我记得中考前，我在一次升旗仪式上，默默的对自己说，我要考上二中对国旗发誓。二中在我心中是下午5点放学，学生自由学习素质教育，然后学习成绩很好。可惜到了发现并不是这样。在高二文理分班后，我们到了0913班，即使很久了我们了并不认识，一开始对你印象不是很深，我们属于不同的人，你篮球打的很好，我是一个几乎不运动的，所以也没什么交集。在一次考试分坐后，我们坐在了一起，我们当时学习成绩一般班级30-40名，中下等，在后3排徘徊。你初始不太友善，不太爱搭理人，我也是这样。但熟了之后，发现你是另外的性格，有点黏人，有点纠结。<br>    你给我印象最深的是，每次考试我们会有一些比较难的大题，老师每次讲解完，我一般会主动放弃，因为它太难，而且以我们现在的成绩，即使做不出来也是正常，你会花时间去扣这些难题，不放弃。我当时觉得你傻，有点不知量力，我自以为的我自己很理智。但我其实是畏惧了，退缩了。你是真的坚持，不退缩，遇到困难，迎难直上。回想起来很佩服，最终你的成绩也是比我好很多，去了东北大学，我因为分数低一些去了南京。<br>    还记得一些细节，高中你会在运动后，带洗面奶去洗脸。说来当时我家里算比较穷的，普通的上班族家庭吧，住在39平的房子里。我当时都没怎么用过洗面奶，第一次看到你用，感觉哇，他家好有钱，好不一样，讲究。后面我也跟你学习，买了洗面奶用，虽然东西不贵，但你身上有种很大方的气质，是我缺乏的，我是很吝啬的，不想与别人分享东西，怕别人抢走，你则不同，主动跟别人共享，境界全然不同，起码那个时候觉得你家里还挺有钱的，起码比我家里好多了。<br>    大学，我们联系得不多，每年过年回家，我们几个吃个饭，随便逛逛，大家一样的烦恼，恋爱，工作。你这个时候还经常去东大学习看书，感觉你还是经常学习。<br>    毕业后，我在上海工作，你也工作了。当时住在闵行，交大附近，突然你说要考上海交大的研究生。我想可以呀，这个很难考的，你都工作一年后，再来考能比得过那些一直学习的吗，我是比较消极的。但你用行动证明了自己，你考上了。不知道你经历了怎么样的痛苦，最终你还在我的小出租房里，跟我住了一个星期，你去复试。我估计当时态度不太好，那时的你有些敏感有些纠结，毕竟在人生转折点。就住了一周，你就走了。我以为你回去了，其实你去做宾馆了，后来知道，我真的很不好意思。我总是觉得别人，蛋疼，做决定纠结这纠结那，左右摇摆。我当时还是自以为理智，但如果我是当事人，估计也会这样。慢慢想来，纠结是人生选择的常态。想起大学毕业去面试的时候说过这么一句话，既然选定了这家企业，我就不会纠结。当时还是听到某个文章推荐这么回答。现在想想还真的是不太对，提前去调查，然后确定某家企业是对的，时间是变动的，企业也是会变的，当初的选择，不代表永恒，后面还是会需要不断的选择。我这个人怕与别人保持太近的距离，当别人靠近的时候，我会主动推开。后来你住进来了学校，我继续加班。<br>    时间过得很快，虽然我们都在上海，离得也不远，但很少相见，只见过1-2天，在交大的校园里。我们也是过年回家，偶尔也聊聊，怎么在上海定居，以后能挣多少钱，你总也是表达了对未来的担心，学的专业没什么发展潜力，不能赚大钱，你也考虑后面也快30了，怎么结婚生子，还没有女朋友，这个时候又觉得你家里没有钱，没法直接安排你后面怎么走，我们同样迷茫，我那时比你挣的多一点，但对未来也是没底。后面听说你要进事业单位了，你说先混了户口，你也觉得没什么发展，但起码有个户口，混1-2年，然后再出来。你也说你可能跟家里亲戚去创业等等。<br>    大概2017年底，2018年初，听说你得白血病了，在水滴凑。我是知道你突然回顾你朋友圈，发现你之前好像打篮球受伤了，伤病回家修养，那个时候还没体会到你发生了什么，以为你还是在矫揉造作。过年回家跟你见了一面，你说你化疗，除了全身没毛外，其他还好。你还是那么乐观。过年回去，跟你吃了顿饭，你虽然看病花了很多钱，但你还是那样的气质，抢着跟我花钱。我不知道怎么面对你，你看起来还不错，说自己不想治了，花那么多钱，想出去玩，但不能动治病的钱。我也在想你要是做骨髓移植，起码花百万，你有这么多钱吗？但你没提跟我借钱，你可能也知道我没什么钱吧，但我确实比你收入多。我当时也想给你多少钱的，我比较纠结，你在面临生命危机，我却在为我自己的未来是不是能买房担心，真的很吝啬，很自私，最终我只给3千，微不足道。<br>    2019年4月，朋友突然给我发你接受采访的报道，说你骨髓移植后，又复发了，时间剩余不多了，你放弃治疗，不想让父母生活品质降低，不想走的很低质量，可能一直插着管子，昏迷等，想安静的走，将遗体捐献给医院，希望给治疗这个病做出贡献。在上班途中，我几乎控制不住自己的苦出来，我不敢问你，不知道怎么跟你开口，一切来的太突然，我还不知道你骨髓移植。没想到这么快，最后的希望，骨髓移植也复发了。最后的手段也不见效了，那确实没有办法了。从你刚的病到现在也就1年多，实在太快了。好绝望，虽然知道很多人死于白血病，但没想到身边人经历后，才发现这个是多么的残酷，多么的无力。我更无法想象，他的父母是什么感受，白发人送黑发人。才刚刚研究生毕业，还是这么好的大学，人生应该是刚刚开始，之前很多都是身不由己，工作后其他自己决定后面的生活，就这样结束了不到30岁。翻看你之前的朋友圈，你18年12月份回了一次上海，发了说想不到外滩这么美。突然泪水控制不住，生命如此短暂，在你刚要开始真正的人生就结束了，你还没有女朋友，你还没有孩子……<br>    迟迟不敢联系你，不知道怎么跟你说，不知道说什么。在五一放假的前一天，跟你联系了，你说在老家往沈阳赶，说自己发烧感觉时间不多了，想回去拿点东西，在海边平静的离去。你他娘的太文艺了，即使走的时候也想文艺的走。看到你在海边的照片，那么美，反差让我控制不住情绪。我下楼走到了外面，不想让认识的人看见，我边走边哭，又尽力控制，我想在下班前跟你视频，找了一圈，在电影广场楼下的银行门前有一块可以坐的地方，在那里又哭了一阵。不甘、心酸，我们相处的总总，没有想到会这样，我的朋友不多，对你也是不太好，你是我不多朋友里经常联系的朋友，本就内向的我很难交朋友，我还以为我们还有大把的时间，不用在意现在，但……<br>    我在想要不要回去，很纠结，听你说，见你最后一面是实现我们一些小愿望，我突然就发现，对于见最后一面，真的是对其他的人的愿望的实现，对你来说，已经无所谓了，这个时候其他都不那么重要了，房子、车子、票子，不能带去，能做的是，为这个世界留下点什么，让其他人还能记得自己，这样也许就是生命的延续。人和人确实不一样，有些人死了，会在大家的思想里，不断延续，其实就是鲜活的生命，肉体死了，灵魂永存。<br>    走在大街上，看着其他人继续的日子，突然感觉不那么真实，有些人可能是以后几天，有些却在虚度、打发时间，有些人欢声笑语，有些人却没有希望。死亡是生命的一部分，一个必然的阶段。只是大家觉得自己不会那么快，还有很多时间，人生需要阶段规划，我想让我的人生不那么遗憾，能思前想后，发现想做的都做到了，没有什么遗憾了。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/人文/">人文</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/感悟/">感悟</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/05/05/arts-2019-05-05-tip/" title="java集合-ArrayBlockingQueue" itemprop="url">java集合-ArrayBlockingQueue</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-05-05T02:54:07.000Z" itemprop="datePublished"> Published 2019-05-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>ArrayBlockingQueue是一个有界的阻塞队列，底层实现是一个数组+two-condition并发控制，队列实现使用的是循环数组，并发控制使用ReentrantLock加notEmpty，notFull的condition，如果队列满或空，阻塞线程放入等待队列中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/** The queued items */</span><br><span class="line">final Object[] items;</span><br><span class="line"></span><br><span class="line">/** items index for next take, poll, peek or remove */</span><br><span class="line">int takeIndex;</span><br><span class="line"></span><br><span class="line">/** items index for next put, offer, or add */</span><br><span class="line">int putIndex;</span><br><span class="line"></span><br><span class="line">/** Number of elements in the queue */</span><br><span class="line">int count;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Concurrency control uses the classic two-condition algorithm</span><br><span class="line"> * found in any textbook.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/** Main lock guarding all access */</span><br><span class="line">final ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">/** Condition for waiting takes */</span><br><span class="line">private final Condition notEmpty;</span><br><span class="line"></span><br><span class="line">/** Condition for waiting puts */</span><br><span class="line">private final Condition notFull;</span><br><span class="line">/**</span><br><span class="line"> * Shared state for currently active iterators, or null if there</span><br><span class="line"> * are known not to be any.  Allows queue operations to update</span><br><span class="line"> * iterator state.</span><br><span class="line"> */</span><br><span class="line">transient Itrs itrs = null;</span><br></pre></td></tr></table></figure></p>
<p>item就是实际存储的数组，takeIndex 是弹出的索引，putIndex是压入的索引，count是队列的实际存储的数量。这3个变量配合，count用于判断队列是否空，是否满，takeIndex出队列，putIndex入队列。<br>lock、notEmpty、notFull并发控制，iters是遍历循环，暂时不讲。</p>
<p>构造器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Creates an &#123;@code ArrayBlockingQueue&#125; with the given (fixed)</span><br><span class="line"> * capacity and the specified access policy.</span><br><span class="line"> *</span><br><span class="line"> * @param capacity the capacity of this queue</span><br><span class="line"> * @param fair if &#123;@code true&#125; then queue accesses for threads blocked</span><br><span class="line"> *        on insertion or removal, are processed in FIFO order;</span><br><span class="line"> *        if &#123;@code false&#125; the access order is unspecified.</span><br><span class="line"> * @throws IllegalArgumentException if &#123;@code capacity &lt; 1&#125;</span><br><span class="line"> */</span><br><span class="line">public ArrayBlockingQueue(int capacity, boolean fair) &#123;</span><br><span class="line">    if (capacity &lt;= 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    this.items = new Object[capacity];</span><br><span class="line">    lock = new ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>初始化数组大小，初始化锁，可以传入公平锁还是非公平锁，创建不空、不满条件，给管程等待队列用。<br>入队列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Inserts the specified element at the tail of this queue if it is</span><br><span class="line"> * possible to do so immediately without exceeding the queue&apos;s capacity,</span><br><span class="line"> * returning &#123;@code true&#125; upon success and throwing an</span><br><span class="line"> * &#123;@code IllegalStateException&#125; if this queue is full.</span><br><span class="line"> *</span><br><span class="line"> * @param e the element to add</span><br><span class="line"> * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;)</span><br><span class="line"> * @throws IllegalStateException if this queue is full</span><br><span class="line"> * @throws NullPointerException if the specified element is null</span><br><span class="line"> */</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    return super.add(e);</span><br><span class="line">&#125;</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    if (offer(e))</span><br><span class="line">        return true;</span><br><span class="line">    else</span><br><span class="line">        throw new IllegalStateException(&quot;Queue full&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (count == items.length)</span><br><span class="line">            return false;</span><br><span class="line">        else &#123;</span><br><span class="line">            enqueue(e);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public void put(E e) throws InterruptedException &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public boolean offer(E e, long timeout, TimeUnit unit)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    long nanos = unit.toNanos(timeout);</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (count == items.length) &#123;</span><br><span class="line">            if (nanos &lt;= 0)</span><br><span class="line">                return false;</span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(e);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private void enqueue(E x) &#123;</span><br><span class="line">    // assert lock.getHoldCount() == 1;</span><br><span class="line">    // assert items[putIndex] == null;</span><br><span class="line">    final Object[] items = this.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    if (++putIndex == items.length)</span><br><span class="line">        putIndex = 0;</span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Add、offer（不带超时）方法如果队列满，就会返回false，不会阻塞线程。put、offer（带超时）方法会阻塞线程。offer（带超时）通过中断实现超时，从而按时间返回。<br>enqueue是实际入队列的方法，通过putIndex索引，加入数组，如果putIndex大于数组的长度，从0位置再开始，是一个循环队列。如果入队列了代表，出队列因为数组空的notEmpty阻塞的线程可以重新去执行了，所以notEmpty signal唤醒。 循环队列的空与满，不是通过putIndex与takIndex的位置关系判断了，而是使用了一个新的变量count去判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public E poll() &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        return (count == 0) ? null : dequeue();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (count == 0)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        return dequeue();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public E poll(long timeout, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">    long nanos = unit.toNanos(timeout);</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (count == 0) &#123;</span><br><span class="line">            if (nanos &lt;= 0)</span><br><span class="line">                return null;</span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        return dequeue();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与入站的构造很类似，poll锁不可中断，take与poll（带超时）都可以中断。<br>总结：ArrayBlocking 是一个有界循环队列，并发控制使用ReentrantLock的two-condition，队列空阻塞出队列，队列满阻塞入队列。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/后端/">后端</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/编程技巧/">编程技巧</a><a href="/tags/java/">java</a><a href="/tags/集合/">集合</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/04/28/arts-2019-04-28-tip/" title="java集合-PriorityQueue" itemprop="url">java集合-PriorityQueue</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-04-28T02:48:07.000Z" itemprop="datePublished"> Published 2019-04-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>实现数据结构是堆，堆底层实现结构是数组，堆是完全二叉树。<br>主要的成员变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Priority queue represented as a balanced binary heap: the two</span><br><span class="line"> * children of queue[n] are queue[2*n+1] and queue[2*(n+1)].  The</span><br><span class="line"> * priority queue is ordered by comparator, or by the elements&apos;</span><br><span class="line"> * natural ordering, if comparator is null: For each node n in the</span><br><span class="line"> * heap and each descendant d of n, n &lt;= d.  The element with the</span><br><span class="line"> * lowest value is in queue[0], assuming the queue is nonempty.</span><br><span class="line"> */</span><br><span class="line">transient Object[] queue; // non-private to simplify nested class access</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The number of elements in the priority queue.</span><br><span class="line"> */</span><br><span class="line">private int size = 0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The comparator, or null if priority queue uses elements&apos;</span><br><span class="line"> * natural ordering.</span><br><span class="line"> */</span><br><span class="line">private final Comparator&lt;? super E&gt; comparator;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The number of times this priority queue has been</span><br><span class="line"> * &lt;i&gt;structurally modified&lt;/i&gt;.  See AbstractList for gory details.</span><br><span class="line"> */</span><br><span class="line">transient int modCount = 0; // non-private to simplify nested class access</span><br></pre></td></tr></table></figure>
<p>queue是堆的底层实现，size是记录堆的大小的，comparator是自己实现比较方法的，可以实现大顶堆和小顶堆，mouCount用于控制并发</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Creates a &#123;@code PriorityQueue&#125; with the specified initial capacity</span><br><span class="line"> * that orders its elements according to the specified comparator.</span><br><span class="line"> *</span><br><span class="line"> * @param  initialCapacity the initial capacity for this priority queue</span><br><span class="line"> * @param  comparator the comparator that will be used to order this</span><br><span class="line"> *         priority queue.  If &#123;@code null&#125;, the &#123;@linkplain Comparable</span><br><span class="line"> *         natural ordering&#125; of the elements will be used.</span><br><span class="line"> * @throws IllegalArgumentException if &#123;@code initialCapacity&#125; is</span><br><span class="line"> *         less than 1</span><br><span class="line"> */</span><br><span class="line">public PriorityQueue(int initialCapacity,</span><br><span class="line">                     Comparator&lt;? super E&gt; comparator) &#123;</span><br><span class="line">    // Note: This restriction of at least one is not actually needed,</span><br><span class="line">    // but continues for 1.5 compatibility</span><br><span class="line">    if (initialCapacity &lt; 1)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    this.queue = new Object[initialCapacity];</span><br><span class="line">    this.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化的时候，可以自定义比较器和容器大小，默认是11<br>主要方法<br>添加数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Inserts the specified element into this priority queue.</span><br><span class="line"> *</span><br><span class="line"> * @return &#123;@code true&#125; (as specified by &#123;@link Queue#offer&#125;)</span><br><span class="line"> * @throws ClassCastException if the specified element cannot be</span><br><span class="line"> *         compared with elements currently in this priority queue</span><br><span class="line"> *         according to the priority queue&apos;s ordering</span><br><span class="line"> * @throws NullPointerException if the specified element is null</span><br><span class="line"> */</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    if (e == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    modCount++;</span><br><span class="line">    int i = size;</span><br><span class="line">    if (i &gt;= queue.length)</span><br><span class="line">        grow(i + 1);</span><br><span class="line">    size = i + 1;</span><br><span class="line">    if (i == 0)</span><br><span class="line">        queue[0] = e;</span><br><span class="line">    else</span><br><span class="line">        siftUp(i, e);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果队列大小与容量上限一直，就去扩容，从最后一位去向上堆化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Increases the capacity of the array.</span><br><span class="line"> *</span><br><span class="line"> * @param minCapacity the desired minimum capacity</span><br><span class="line"> */</span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    int oldCapacity = queue.length;</span><br><span class="line">    // Double size if small; else grow by 50%</span><br><span class="line">    int newCapacity = oldCapacity + ((oldCapacity &lt; 64) ?</span><br><span class="line">                                     (oldCapacity + 2) :</span><br><span class="line">                                     (oldCapacity &gt;&gt; 1));</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>扩容方法，如果容量小于64 ，则一次扩容 2n+2，大于则 扩容1.5n，最后复制原来数组到新数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">* Inserts item x at position k, maintaining heap invariant by</span><br><span class="line"> * promoting x up the tree until it is greater than or equal to</span><br><span class="line"> * its parent, or is the root.</span><br><span class="line"> *</span><br><span class="line"> * To simplify and speed up coercions and comparisons. the</span><br><span class="line"> * Comparable and Comparator versions are separated into different</span><br><span class="line"> * methods that are otherwise identical. (Similarly for siftDown.)</span><br><span class="line"> *</span><br><span class="line"> * @param k the position to fill</span><br><span class="line"> * @param x the item to insert</span><br><span class="line"> */</span><br><span class="line">private void siftUp(int k, E x) &#123;</span><br><span class="line">    if (comparator != null)</span><br><span class="line">        siftUpUsingComparator(k, x);</span><br><span class="line">    else</span><br><span class="line">        siftUpComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">private void siftUpComparable(int k, E x) &#123;</span><br><span class="line">    Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;) x;</span><br><span class="line">    while (k &gt; 0) &#123;</span><br><span class="line">        int parent = (k - 1) &gt;&gt;&gt; 1;</span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        if (key.compareTo((E) e) &gt;= 0)</span><br><span class="line">            break;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">&#125;</span><br><span class="line">private void siftUpUsingComparator(int k, E x) &#123;</span><br><span class="line">    while (k &gt; 0) &#123;</span><br><span class="line">        int parent = (k - 1) &gt;&gt;&gt; 1;</span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        if (comparator.compare(x, (E) e) &gt;= 0)</span><br><span class="line">            break;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>向上堆化，如果自定义了比较器 就用siftUpUsingComparator，其他就用默认的比较器，按字母顺序排序，两个方法实现基本相同<br>K是新插入的节点的索引，它的父是（ k-1）/2，这个地方跟一般的堆有些区别，是从0开始算的，父是n，左子树是2n+1，右子树是2（n+1）<br>优先级小的在上面，如果遇到子比父优先级大，结束，将x赋值给k位。如果父优先级更大，将父的值赋给子节点，继续比较父的父级，知道k=0.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public E poll() &#123;</span><br><span class="line">    if (size == 0)</span><br><span class="line">        return null;</span><br><span class="line">    int s = --size;</span><br><span class="line">    modCount++;</span><br><span class="line">    E result = (E) queue[0];</span><br><span class="line">    E x = (E) queue[s];</span><br><span class="line">    queue[s] = null;</span><br><span class="line">    if (s != 0)</span><br><span class="line">        siftDown(0, x);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>弹出堆顶值，queue[0]是优先级最小的，要弹出的值，sfitDown是从堆顶向堆底堆化，从最后一位取一个值，放到堆顶，然后从顶开始堆化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Inserts item x at position k, maintaining heap invariant by</span><br><span class="line"> * demoting x down the tree repeatedly until it is less than or</span><br><span class="line"> * equal to its children or is a leaf.</span><br><span class="line"> *</span><br><span class="line"> * @param k the position to fill</span><br><span class="line"> * @param x the item to insert</span><br><span class="line"> */</span><br><span class="line">private void siftDown(int k, E x) &#123;</span><br><span class="line">    if (comparator != null)</span><br><span class="line">        siftDownUsingComparator(k, x);</span><br><span class="line">    else</span><br><span class="line">        siftDownComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">private void siftDownComparable(int k, E x) &#123;</span><br><span class="line">    Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;)x;</span><br><span class="line">    int half = size &gt;&gt;&gt; 1;        // loop while a non-leaf</span><br><span class="line">    while (k &lt; half) &#123;</span><br><span class="line">        int child = (k &lt;&lt; 1) + 1; // assume left child is least</span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        int right = child + 1;</span><br><span class="line">        if (right &lt; size &amp;&amp;</span><br><span class="line">            ((Comparable&lt;? super E&gt;) c).compareTo((E) queue[right]) &gt; 0)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        if (key.compareTo((E) c) &lt;= 0)</span><br><span class="line">            break;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">&#125;</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">private void siftDownUsingComparator(int k, E x) &#123;</span><br><span class="line">    int half = size &gt;&gt;&gt; 1;</span><br><span class="line">    while (k &lt; half) &#123;</span><br><span class="line">        int child = (k &lt;&lt; 1) + 1;</span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        int right = child + 1;</span><br><span class="line">        if (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; 0)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        if (comparator.compare(x, (E) c) &lt;= 0)</span><br><span class="line">            break;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟从下到上结构相似，看是否有自实现的比较器。<br>size/2 是差不多最后一个非叶子节点，最后到这个节点去堆化，从k=0 开始，其次与左右子树比，谁优先级更小，不断循环，直到x的优先级，小于某个的节点，然后放置到k处</p>
<p>总结<br>优先级队列，底层数据结构是堆，堆的底层数据结构是数组，每次插入和删除，都要堆化，有2种堆化方式，一种是从上到下，一种是从下到上。从数组角度去理解还是有点难度的，需要想象成树的结构，然后根据序号存储在数组内。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/后端/">后端</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/编程技巧/">编程技巧</a><a href="/tags/java/">java</a><a href="/tags/集合/">集合</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/04/28/arts-2019-04-28-review/" title="Distributed Systems for fun and profit Explained 学习笔记" itemprop="url">Distributed Systems for fun and profit Explained 学习笔记</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-04-28T02:44:07.000Z" itemprop="datePublished"> Published 2019-04-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>作者撰写此书的目的希望以一种更易于理解的方式，讲述以亚马逊的Dynamo、谷歌的Bigtable和MaReduce等为代表的分布式系统背后的核心思想<br>看了一遍，英语也有点差，每天看一周才勉强看完一遍，内容还穿不起来，需要再多看几遍。<br>作者看来分布式只有2件事，一个是 数据传输速率不会超过光速，第二个，独立的节点独立的失败<br>换句话是说是处理距离和不止一件事。处理距离、时间和同步模型。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/英语原文/">英语原文</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/分布式/">分布式</a><a href="/tags/架构/">架构</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/04/28/arts-2019-04-28-share/" title="《7up》第二遍观后感3" itemprop="url">《7up》第二遍观后感3</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-04-28T02:28:07.000Z" itemprop="datePublished"> Published 2019-04-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>从两个角度去看这部片子，从吴军的近代史纲得到的启示，回望与俯瞰。<br><strong>回望了解历史进程，俯瞰查看因素的关联，掌握历史的规律。 </strong></p>
<p>首先每个人的记录看成这个人的历史，这些人的记录总和是英国的历史，可以一窥历史，并不能完全代表。<br>从每个人的历史看一个人一生应该经历的各种事情，提前规划。<br>横向看每个人的历史，就是英国的历史，看英国历史是如何发展。</p>
<h2 id="个人历史"><a href="#个人历史" class="headerlink" title="个人历史"></a>个人历史</h2><p>回望人生，大概几个阶段<br>1.上学，接受教育<br>2.工作<br>3.婚姻<br>4.孩子<br>5.养老</p>
<p>上学阶段的区分是上公立学校还是私立学校，大学是文法大学还是综合性大学，是否读预科为上大学做准备。</p>
<p>工作提供金钱，是保证你生活的水平，后面的发展如何，有些人的工作到了40-50多岁因为经济原因被取消，导致没有收入。金钱保证你是否能做想做的事情。</p>
<p>婚姻，什么时间去结婚，是否离婚，婚后生活如何，如果两个人共同生活。<br>什么时候要孩子，要几个孩子，怎么教育孩子。</p>
<p>养老，才56岁，没有提及。</p>
<h3 id="上学阶段"><a href="#上学阶段" class="headerlink" title="上学阶段"></a>上学阶段</h3><p>家庭原因，会给一个人造成永久的影响，尤其是童年，父母离婚，父母的爱，家庭的温暖，<br>眼界的扩展，是否出去旅游，关心的事情，空闲时间都在做什么<br>分化从这个时候开始，私立教育提供很大的机会上更好的大学，为未来提高更高的门槛。<br>童年的不幸会影响一个人很久，有些非婚、或者离婚家庭的孩子，对未来会很不自信，缺乏安全感。<br>后面比较成功的孩子，都是对未来有一些规划，但很多没有想很清楚，未来也是没有目标去努力。</p>
<h3 id="工作阶段"><a href="#工作阶段" class="headerlink" title="工作阶段"></a>工作阶段</h3><p>工作是一个人未来生活的基础，如果没有足够的收入，生活总是会做捉襟见肘，生活比较富裕的，基本是从事律师，达到合伙人的阶段，<br>生活才能比较轻松，养育子女，才能没有那么多局促</p>
<h3 id="婚姻阶段"><a href="#婚姻阶段" class="headerlink" title="婚姻阶段"></a>婚姻阶段</h3><p>何时结婚，大部分人在很年轻的时候就结婚，然后离婚再婚，有些着是比较晚结婚，有人婚内出轨，看你如何经营婚姻，好的婚姻两个人互相滋养，坏的互相消耗，两个如何相处，日常琐事如何处理。</p>
<h3 id="养育子女阶段"><a href="#养育子女阶段" class="headerlink" title="养育子女阶段"></a>养育子女阶段</h3><p>生育几个孩子，如何培养孩子，如何跟子女相处，有的人离婚自己养育孩子，有的人生一大堆孩子然后离婚，子女生活遇到一些问题，如何分担</p>
<h2 id="从个人里看英国发展"><a href="#从个人里看英国发展" class="headerlink" title="从个人里看英国发展"></a>从个人里看英国发展</h2><p>整体国力在下降，面临就业岗位减少，很多人找不到工作。<br>私立教育与公立教育差异很大，有钱人就读私立更好的资源，加剧阶级分化。<br>离婚情况比较多，癌症概率很大。<br>种族问题。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/人文/">人文</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/感悟/">感悟</a><a href="/tags/纪录片/">纪录片</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/04/28/arts-2019-04-28-algorithm/" title="数组中的第K个最大元素" itemprop="url">数组中的第K个最大元素</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-04-28T02:28:07.000Z" itemprop="datePublished"> Published 2019-04-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br>示例 1:<br>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5<br>示例 2:<br>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>输出: 4<br>说明:<br>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p>
<h2 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h2><p>插入一个k大小的最小堆，<br>满了之后，再最小值比较，然后从上到下堆化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findKthLargest(int[] nums, int k) &#123;</span><br><span class="line">        Heap heap = new Heap(k);</span><br><span class="line">        for(int i = 0; i&lt; nums.length ; i++)&#123;</span><br><span class="line">            heap.insert(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return heap.maxK();</span><br><span class="line">    &#125;</span><br><span class="line">    static class Heap&#123;</span><br><span class="line">        int[] nums;</span><br><span class="line">        int count;</span><br><span class="line">        int capacity;</span><br><span class="line">        public Heap(int capacity)&#123;</span><br><span class="line">            this.nums = new int[capacity+1];</span><br><span class="line">            this.count = 0;</span><br><span class="line">            this.capacity = capacity;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public void insert(int num)&#123;</span><br><span class="line">            if( count &lt; capacity)&#123;</span><br><span class="line">                notFullInsert(num);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                fullInsert(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public void fullInsert(int num)&#123;</span><br><span class="line">            int min = nums[1];</span><br><span class="line">            if(num &lt; min)&#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[1] = num;</span><br><span class="line">            int minPos = 1;</span><br><span class="line">            int i = 1;</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                if(i*2 &lt;= capacity &amp;&amp; nums[i] &gt; nums[i*2])&#123;minPos = i*2;&#125;           </span><br><span class="line">                if(i*2+1 &lt;= capacity &amp;&amp; nums[minPos] &gt; nums[i*2+1])&#123;minPos = i*2+1;&#125;</span><br><span class="line">                if(i== minPos)break;</span><br><span class="line">                swap(nums,i,minPos);</span><br><span class="line">                i = minPos;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        public void notFullInsert(int num)&#123;</span><br><span class="line">            int index = count+1;</span><br><span class="line">            nums[index] = num;</span><br><span class="line">            count++;</span><br><span class="line">            while(index/2 &gt; 0 &amp;&amp; nums[index/2] &gt; nums[index])&#123;</span><br><span class="line">                swap(nums,index , index/2);</span><br><span class="line">                index = index/2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public void swap(int[] array, int fromIndex ,int toIndex)&#123;</span><br><span class="line">            int tmp = array[toIndex];</span><br><span class="line">            array[toIndex] = array[fromIndex];</span><br><span class="line">            array[fromIndex] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        public int maxK()&#123;</span><br><span class="line">            return nums[1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><p>先填充 k个大小的数组，然后从下到上进行堆化，<br>满了之后，再最小值比较，然后从上到下堆化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findKthLargest(int[] nums, int k) &#123;</span><br><span class="line">        int[] arrays = new int[k+1];</span><br><span class="line">        </span><br><span class="line">        for(int i = 1 ; i&lt;= k ; i++ )&#123;</span><br><span class="line">            arrays[i] = nums[i-1];</span><br><span class="line">        &#125;</span><br><span class="line">        initTree(arrays);</span><br><span class="line">        </span><br><span class="line">        for(int i = k ; i&lt; nums.length ; i++)&#123;</span><br><span class="line">            int min = arrays[1];</span><br><span class="line">            if(min &lt; nums[i])&#123; </span><br><span class="line">                arrays[1] = nums[i];</span><br><span class="line">                heapify(arrays,1, k);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return arrays[1];</span><br><span class="line">    &#125;</span><br><span class="line">    private void initTree(int[] array)&#123;</span><br><span class="line">        for(int i = array.length/2; i&gt;= 1;i--)&#123;</span><br><span class="line">            heapify(array, i, array.length -1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void heapify(int[] array,int i, int n)&#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            int minPos = i;</span><br><span class="line">            if(i*2 &lt;= n &amp;&amp; array[i] &gt; array[i*2])&#123; </span><br><span class="line">                minPos = i*2;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i*2+1 &lt;= n &amp;&amp; array[minPos] &gt; array[i*2+1])&#123;minPos = i*2+1;&#125;</span><br><span class="line">            if(minPos == i)break;</span><br><span class="line">            swap(array, i, minPos);</span><br><span class="line">            i = minPos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    public void swap(int[] nums , int fromIndex , int toIndex)&#123;</span><br><span class="line">        int tmp = nums[toIndex];</span><br><span class="line">        nums[toIndex] = nums[fromIndex];</span><br><span class="line">        nums[fromIndex] = tmp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/leetcode/">leetcode</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/算法/">算法</a><a href="/tags/堆/">堆</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/04/21/arts-2019-04-21-share/" title="关于这段时间学习的分析" itemprop="url">关于这段时间学习的分析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-04-21T07:49:07.000Z" itemprop="datePublished"> Published 2019-04-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>这段时间在以阿里的标准去复习，发现自己之前真的很多不会的。基础的集合类从来没想过要了解它的实现，不知道实现就不知道它的限制，这样是不可能使用好的。虚拟机没有看过，当时觉得虚拟机太复杂，还没腾出时间去看。并发没有好好研究，它和虚拟机一样也是认为它太难了。算法，数据结构也是，一直认为它很重要，但遇到点困难就退缩了，回到舒适区。这些困难可能暂时不会影响到那时的我，所以我也没有太在意，虽然他们都在，也都知道，但重要性没有那么高。</p>
<p>最近再把这些知识作为必须要学会的内容去学习，开头很难，制定计划内心都是拒绝的，开始1-2个星期，1天只能坐1-2道算法题，那个时候内心是崩溃的，但过了1-2个月，发现情况出现好转，每天做题的速度慢慢上来了。虽然并发还是不怎么会，但通过订阅别人的专栏，我发现，一开始不会的时候，知识的凌乱的，但通过师傅寻找内在的逻辑，精心编怕，你可以找到秩序，把混乱变成有序，需要付出努力，自然界是熵增的。<strong>学习就是这样一个过程， 把无序变成有序。</strong></p>
<p>从我女朋友学编程这件事来说，我一直想教她，但我理不出头绪，一般就是扔一本书给她，或者开头热教她一下，但过不了1个星期就不继续了，这是我没有吃透的表现，没有从混乱转变成有序，也不能将这种有序传授给别人。李笑来之前就说他口头教会别人游泳，说明功力很深厚，我也尝试教女朋友，模仿我学习的过程，但效果一般，我没有掌握好各种过渡的阶段，无法有效的表达。很多时候就是这样，明明自己会，但你不敢说会，因为你不能教会别人。<strong>以教为学</strong>很重要。</p>
<p>最近也体会到一个人意志坚定的重要性，认准一个道理，身边的不同人会给你不同的压力，顶住压力，你就能突破自我，完成进化。屈从压力，你可能会继续随波逐流，活在别人的阴影中，别人的意志里。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/人文/">人文</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/感悟/">感悟</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/7/"><span></span>Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/9/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Java语言基础/" title="Java语言基础">Java语言基础<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Spring/" title="Spring">Spring<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/leetcode/" title="leetcode">leetcode<sup>26</sup></a></li>
		  
		
		  
			<li><a href="/categories/人文/" title="人文">人文<sup>31</sup></a></li>
		  
		
		  
			<li><a href="/categories/前端/" title="前端">前端<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/后端/" title="后端">后端<sup>27</sup></a></li>
		  
		
		  
			<li><a href="/categories/成长/" title="成长">成长<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/树莓派/" title="树莓派">树莓派<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/监控/" title="监控">监控<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/英语原文/" title="英语原文">英语原文<sup>12</sup></a></li>
		  
		
		  
			<li><a href="/categories/闲谈/" title="闲谈">闲谈<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/感悟/" title="感悟">感悟<sup>31</sup></a></li>
			
		
			
				<li><a href="/tags/编程技巧/" title="编程技巧">编程技巧<sup>29</sup></a></li>
			
		
			
				<li><a href="/tags/算法/" title="算法">算法<sup>26</sup></a></li>
			
		
			
				<li><a href="/tags/java/" title="java">java<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/架构/" title="架构">架构<sup>13</sup></a></li>
			
		
			
				<li><a href="/tags/分布式/" title="分布式">分布式<sup>12</sup></a></li>
			
		
			
				<li><a href="/tags/计算机组成/" title="计算机组成">计算机组成<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/纪录片/" title="纪录片">纪录片<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/电视剧/" title="电视剧">电视剧<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/字符串/" title="字符串">字符串<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/链表/" title="链表">链表<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/集合/" title="集合">集合<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/并发集合/" title="并发集合">并发集合<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/动态规划/" title="动态规划">动态规划<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/历史/" title="历史">历史<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/学习方法/" title="学习方法">学习方法<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/单元测试/" title="单元测试">单元测试<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Trie树/" title="Trie树">Trie树<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/vue/" title="vue">vue<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/树/" title="树">树<sup>2</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Larry Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2020 
		
		<a href="/about" target="_blank" title="R_Richie">R_Richie</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
