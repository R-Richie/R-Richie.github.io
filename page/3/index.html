
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>演练场</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="R_Richie">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="演练场">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="演练场">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="演练场">

    
    <link rel="alternative" href="/atom.xml" title="演练场" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="演练场" title="演练场"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="演练场">演练场</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/04/28/arts-2019-04-28-tip/" title="java集合-PriorityQueue" itemprop="url">java集合-PriorityQueue</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-04-28T02:48:07.000Z" itemprop="datePublished"> Published 2019-04-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>实现数据结构是堆，堆底层实现结构是数组，堆是完全二叉树。<br>主要的成员变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Priority queue represented as a balanced binary heap: the two</span><br><span class="line"> * children of queue[n] are queue[2*n+1] and queue[2*(n+1)].  The</span><br><span class="line"> * priority queue is ordered by comparator, or by the elements&apos;</span><br><span class="line"> * natural ordering, if comparator is null: For each node n in the</span><br><span class="line"> * heap and each descendant d of n, n &lt;= d.  The element with the</span><br><span class="line"> * lowest value is in queue[0], assuming the queue is nonempty.</span><br><span class="line"> */</span><br><span class="line">transient Object[] queue; // non-private to simplify nested class access</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The number of elements in the priority queue.</span><br><span class="line"> */</span><br><span class="line">private int size = 0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The comparator, or null if priority queue uses elements&apos;</span><br><span class="line"> * natural ordering.</span><br><span class="line"> */</span><br><span class="line">private final Comparator&lt;? super E&gt; comparator;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The number of times this priority queue has been</span><br><span class="line"> * &lt;i&gt;structurally modified&lt;/i&gt;.  See AbstractList for gory details.</span><br><span class="line"> */</span><br><span class="line">transient int modCount = 0; // non-private to simplify nested class access</span><br></pre></td></tr></table></figure>
<p>queue是堆的底层实现，size是记录堆的大小的，comparator是自己实现比较方法的，可以实现大顶堆和小顶堆，mouCount用于控制并发</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Creates a &#123;@code PriorityQueue&#125; with the specified initial capacity</span><br><span class="line"> * that orders its elements according to the specified comparator.</span><br><span class="line"> *</span><br><span class="line"> * @param  initialCapacity the initial capacity for this priority queue</span><br><span class="line"> * @param  comparator the comparator that will be used to order this</span><br><span class="line"> *         priority queue.  If &#123;@code null&#125;, the &#123;@linkplain Comparable</span><br><span class="line"> *         natural ordering&#125; of the elements will be used.</span><br><span class="line"> * @throws IllegalArgumentException if &#123;@code initialCapacity&#125; is</span><br><span class="line"> *         less than 1</span><br><span class="line"> */</span><br><span class="line">public PriorityQueue(int initialCapacity,</span><br><span class="line">                     Comparator&lt;? super E&gt; comparator) &#123;</span><br><span class="line">    // Note: This restriction of at least one is not actually needed,</span><br><span class="line">    // but continues for 1.5 compatibility</span><br><span class="line">    if (initialCapacity &lt; 1)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    this.queue = new Object[initialCapacity];</span><br><span class="line">    this.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化的时候，可以自定义比较器和容器大小，默认是11<br>主要方法<br>添加数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Inserts the specified element into this priority queue.</span><br><span class="line"> *</span><br><span class="line"> * @return &#123;@code true&#125; (as specified by &#123;@link Queue#offer&#125;)</span><br><span class="line"> * @throws ClassCastException if the specified element cannot be</span><br><span class="line"> *         compared with elements currently in this priority queue</span><br><span class="line"> *         according to the priority queue&apos;s ordering</span><br><span class="line"> * @throws NullPointerException if the specified element is null</span><br><span class="line"> */</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    if (e == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    modCount++;</span><br><span class="line">    int i = size;</span><br><span class="line">    if (i &gt;= queue.length)</span><br><span class="line">        grow(i + 1);</span><br><span class="line">    size = i + 1;</span><br><span class="line">    if (i == 0)</span><br><span class="line">        queue[0] = e;</span><br><span class="line">    else</span><br><span class="line">        siftUp(i, e);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果队列大小与容量上限一直，就去扩容，从最后一位去向上堆化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Increases the capacity of the array.</span><br><span class="line"> *</span><br><span class="line"> * @param minCapacity the desired minimum capacity</span><br><span class="line"> */</span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    int oldCapacity = queue.length;</span><br><span class="line">    // Double size if small; else grow by 50%</span><br><span class="line">    int newCapacity = oldCapacity + ((oldCapacity &lt; 64) ?</span><br><span class="line">                                     (oldCapacity + 2) :</span><br><span class="line">                                     (oldCapacity &gt;&gt; 1));</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>扩容方法，如果容量小于64 ，则一次扩容 2n+2，大于则 扩容1.5n，最后复制原来数组到新数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">* Inserts item x at position k, maintaining heap invariant by</span><br><span class="line"> * promoting x up the tree until it is greater than or equal to</span><br><span class="line"> * its parent, or is the root.</span><br><span class="line"> *</span><br><span class="line"> * To simplify and speed up coercions and comparisons. the</span><br><span class="line"> * Comparable and Comparator versions are separated into different</span><br><span class="line"> * methods that are otherwise identical. (Similarly for siftDown.)</span><br><span class="line"> *</span><br><span class="line"> * @param k the position to fill</span><br><span class="line"> * @param x the item to insert</span><br><span class="line"> */</span><br><span class="line">private void siftUp(int k, E x) &#123;</span><br><span class="line">    if (comparator != null)</span><br><span class="line">        siftUpUsingComparator(k, x);</span><br><span class="line">    else</span><br><span class="line">        siftUpComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">private void siftUpComparable(int k, E x) &#123;</span><br><span class="line">    Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;) x;</span><br><span class="line">    while (k &gt; 0) &#123;</span><br><span class="line">        int parent = (k - 1) &gt;&gt;&gt; 1;</span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        if (key.compareTo((E) e) &gt;= 0)</span><br><span class="line">            break;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">&#125;</span><br><span class="line">private void siftUpUsingComparator(int k, E x) &#123;</span><br><span class="line">    while (k &gt; 0) &#123;</span><br><span class="line">        int parent = (k - 1) &gt;&gt;&gt; 1;</span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        if (comparator.compare(x, (E) e) &gt;= 0)</span><br><span class="line">            break;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>向上堆化，如果自定义了比较器 就用siftUpUsingComparator，其他就用默认的比较器，按字母顺序排序，两个方法实现基本相同<br>K是新插入的节点的索引，它的父是（ k-1）/2，这个地方跟一般的堆有些区别，是从0开始算的，父是n，左子树是2n+1，右子树是2（n+1）<br>优先级小的在上面，如果遇到子比父优先级大，结束，将x赋值给k位。如果父优先级更大，将父的值赋给子节点，继续比较父的父级，知道k=0.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public E poll() &#123;</span><br><span class="line">    if (size == 0)</span><br><span class="line">        return null;</span><br><span class="line">    int s = --size;</span><br><span class="line">    modCount++;</span><br><span class="line">    E result = (E) queue[0];</span><br><span class="line">    E x = (E) queue[s];</span><br><span class="line">    queue[s] = null;</span><br><span class="line">    if (s != 0)</span><br><span class="line">        siftDown(0, x);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>弹出堆顶值，queue[0]是优先级最小的，要弹出的值，sfitDown是从堆顶向堆底堆化，从最后一位取一个值，放到堆顶，然后从顶开始堆化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Inserts item x at position k, maintaining heap invariant by</span><br><span class="line"> * demoting x down the tree repeatedly until it is less than or</span><br><span class="line"> * equal to its children or is a leaf.</span><br><span class="line"> *</span><br><span class="line"> * @param k the position to fill</span><br><span class="line"> * @param x the item to insert</span><br><span class="line"> */</span><br><span class="line">private void siftDown(int k, E x) &#123;</span><br><span class="line">    if (comparator != null)</span><br><span class="line">        siftDownUsingComparator(k, x);</span><br><span class="line">    else</span><br><span class="line">        siftDownComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">private void siftDownComparable(int k, E x) &#123;</span><br><span class="line">    Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;)x;</span><br><span class="line">    int half = size &gt;&gt;&gt; 1;        // loop while a non-leaf</span><br><span class="line">    while (k &lt; half) &#123;</span><br><span class="line">        int child = (k &lt;&lt; 1) + 1; // assume left child is least</span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        int right = child + 1;</span><br><span class="line">        if (right &lt; size &amp;&amp;</span><br><span class="line">            ((Comparable&lt;? super E&gt;) c).compareTo((E) queue[right]) &gt; 0)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        if (key.compareTo((E) c) &lt;= 0)</span><br><span class="line">            break;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">&#125;</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">private void siftDownUsingComparator(int k, E x) &#123;</span><br><span class="line">    int half = size &gt;&gt;&gt; 1;</span><br><span class="line">    while (k &lt; half) &#123;</span><br><span class="line">        int child = (k &lt;&lt; 1) + 1;</span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        int right = child + 1;</span><br><span class="line">        if (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; 0)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        if (comparator.compare(x, (E) c) &lt;= 0)</span><br><span class="line">            break;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟从下到上结构相似，看是否有自实现的比较器。<br>size/2 是差不多最后一个非叶子节点，最后到这个节点去堆化，从k=0 开始，其次与左右子树比，谁优先级更小，不断循环，直到x的优先级，小于某个的节点，然后放置到k处</p>
<p>总结<br>优先级队列，底层数据结构是堆，堆的底层数据结构是数组，每次插入和删除，都要堆化，有2种堆化方式，一种是从上到下，一种是从下到上。从数组角度去理解还是有点难度的，需要想象成树的结构，然后根据序号存储在数组内。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/后端/">后端</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/编程技巧/">编程技巧</a><a href="/tags/java/">java</a><a href="/tags/集合/">集合</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/04/28/arts-2019-04-28-review/" title="Distributed Systems for fun and profit Explained 学习笔记" itemprop="url">Distributed Systems for fun and profit Explained 学习笔记</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-04-28T02:44:07.000Z" itemprop="datePublished"> Published 2019-04-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>作者撰写此书的目的希望以一种更易于理解的方式，讲述以亚马逊的Dynamo、谷歌的Bigtable和MaReduce等为代表的分布式系统背后的核心思想<br>看了一遍，英语也有点差，每天看一周才勉强看完一遍，内容还穿不起来，需要再多看几遍。<br>作者看来分布式只有2件事，一个是 数据传输速率不会超过光速，第二个，独立的节点独立的失败<br>换句话是说是处理距离和不止一件事。处理距离、时间和同步模型。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/英语原文/">英语原文</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/分布式/">分布式</a><a href="/tags/架构/">架构</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/04/28/arts-2019-04-28-algorithm/" title="数组中的第K个最大元素" itemprop="url">数组中的第K个最大元素</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-04-28T02:28:07.000Z" itemprop="datePublished"> Published 2019-04-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br>示例 1:<br>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5<br>示例 2:<br>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>输出: 4<br>说明:<br>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p>
<h2 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h2><p>插入一个k大小的最小堆，<br>满了之后，再最小值比较，然后从上到下堆化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findKthLargest(int[] nums, int k) &#123;</span><br><span class="line">        Heap heap = new Heap(k);</span><br><span class="line">        for(int i = 0; i&lt; nums.length ; i++)&#123;</span><br><span class="line">            heap.insert(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return heap.maxK();</span><br><span class="line">    &#125;</span><br><span class="line">    static class Heap&#123;</span><br><span class="line">        int[] nums;</span><br><span class="line">        int count;</span><br><span class="line">        int capacity;</span><br><span class="line">        public Heap(int capacity)&#123;</span><br><span class="line">            this.nums = new int[capacity+1];</span><br><span class="line">            this.count = 0;</span><br><span class="line">            this.capacity = capacity;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public void insert(int num)&#123;</span><br><span class="line">            if( count &lt; capacity)&#123;</span><br><span class="line">                notFullInsert(num);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                fullInsert(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public void fullInsert(int num)&#123;</span><br><span class="line">            int min = nums[1];</span><br><span class="line">            if(num &lt; min)&#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[1] = num;</span><br><span class="line">            int minPos = 1;</span><br><span class="line">            int i = 1;</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                if(i*2 &lt;= capacity &amp;&amp; nums[i] &gt; nums[i*2])&#123;minPos = i*2;&#125;           </span><br><span class="line">                if(i*2+1 &lt;= capacity &amp;&amp; nums[minPos] &gt; nums[i*2+1])&#123;minPos = i*2+1;&#125;</span><br><span class="line">                if(i== minPos)break;</span><br><span class="line">                swap(nums,i,minPos);</span><br><span class="line">                i = minPos;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        public void notFullInsert(int num)&#123;</span><br><span class="line">            int index = count+1;</span><br><span class="line">            nums[index] = num;</span><br><span class="line">            count++;</span><br><span class="line">            while(index/2 &gt; 0 &amp;&amp; nums[index/2] &gt; nums[index])&#123;</span><br><span class="line">                swap(nums,index , index/2);</span><br><span class="line">                index = index/2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public void swap(int[] array, int fromIndex ,int toIndex)&#123;</span><br><span class="line">            int tmp = array[toIndex];</span><br><span class="line">            array[toIndex] = array[fromIndex];</span><br><span class="line">            array[fromIndex] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        public int maxK()&#123;</span><br><span class="line">            return nums[1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><p>先填充 k个大小的数组，然后从下到上进行堆化，<br>满了之后，再最小值比较，然后从上到下堆化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findKthLargest(int[] nums, int k) &#123;</span><br><span class="line">        int[] arrays = new int[k+1];</span><br><span class="line">        </span><br><span class="line">        for(int i = 1 ; i&lt;= k ; i++ )&#123;</span><br><span class="line">            arrays[i] = nums[i-1];</span><br><span class="line">        &#125;</span><br><span class="line">        initTree(arrays);</span><br><span class="line">        </span><br><span class="line">        for(int i = k ; i&lt; nums.length ; i++)&#123;</span><br><span class="line">            int min = arrays[1];</span><br><span class="line">            if(min &lt; nums[i])&#123; </span><br><span class="line">                arrays[1] = nums[i];</span><br><span class="line">                heapify(arrays,1, k);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return arrays[1];</span><br><span class="line">    &#125;</span><br><span class="line">    private void initTree(int[] array)&#123;</span><br><span class="line">        for(int i = array.length/2; i&gt;= 1;i--)&#123;</span><br><span class="line">            heapify(array, i, array.length -1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void heapify(int[] array,int i, int n)&#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            int minPos = i;</span><br><span class="line">            if(i*2 &lt;= n &amp;&amp; array[i] &gt; array[i*2])&#123; </span><br><span class="line">                minPos = i*2;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i*2+1 &lt;= n &amp;&amp; array[minPos] &gt; array[i*2+1])&#123;minPos = i*2+1;&#125;</span><br><span class="line">            if(minPos == i)break;</span><br><span class="line">            swap(array, i, minPos);</span><br><span class="line">            i = minPos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    public void swap(int[] nums , int fromIndex , int toIndex)&#123;</span><br><span class="line">        int tmp = nums[toIndex];</span><br><span class="line">        nums[toIndex] = nums[fromIndex];</span><br><span class="line">        nums[fromIndex] = tmp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/leetcode/">leetcode</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/算法/">算法</a><a href="/tags/堆/">堆</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/04/28/arts-2019-04-28-share/" title="《7up》第二遍观后感3" itemprop="url">《7up》第二遍观后感3</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-04-28T02:28:07.000Z" itemprop="datePublished"> Published 2019-04-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>从两个角度去看这部片子，从吴军的近代史纲得到的启示，回望与俯瞰。<br><strong>回望了解历史进程，俯瞰查看因素的关联，掌握历史的规律。 </strong></p>
<p>首先每个人的记录看成这个人的历史，这些人的记录总和是英国的历史，可以一窥历史，并不能完全代表。<br>从每个人的历史看一个人一生应该经历的各种事情，提前规划。<br>横向看每个人的历史，就是英国的历史，看英国历史是如何发展。</p>
<h2 id="个人历史"><a href="#个人历史" class="headerlink" title="个人历史"></a>个人历史</h2><p>回望人生，大概几个阶段<br>1.上学，接受教育<br>2.工作<br>3.婚姻<br>4.孩子<br>5.养老</p>
<p>上学阶段的区分是上公立学校还是私立学校，大学是文法大学还是综合性大学，是否读预科为上大学做准备。</p>
<p>工作提供金钱，是保证你生活的水平，后面的发展如何，有些人的工作到了40-50多岁因为经济原因被取消，导致没有收入。金钱保证你是否能做想做的事情。</p>
<p>婚姻，什么时间去结婚，是否离婚，婚后生活如何，如果两个人共同生活。<br>什么时候要孩子，要几个孩子，怎么教育孩子。</p>
<p>养老，才56岁，没有提及。</p>
<h3 id="上学阶段"><a href="#上学阶段" class="headerlink" title="上学阶段"></a>上学阶段</h3><p>家庭原因，会给一个人造成永久的影响，尤其是童年，父母离婚，父母的爱，家庭的温暖，<br>眼界的扩展，是否出去旅游，关心的事情，空闲时间都在做什么<br>分化从这个时候开始，私立教育提供很大的机会上更好的大学，为未来提高更高的门槛。<br>童年的不幸会影响一个人很久，有些非婚、或者离婚家庭的孩子，对未来会很不自信，缺乏安全感。<br>后面比较成功的孩子，都是对未来有一些规划，但很多没有想很清楚，未来也是没有目标去努力。</p>
<h3 id="工作阶段"><a href="#工作阶段" class="headerlink" title="工作阶段"></a>工作阶段</h3><p>工作是一个人未来生活的基础，如果没有足够的收入，生活总是会做捉襟见肘，生活比较富裕的，基本是从事律师，达到合伙人的阶段，<br>生活才能比较轻松，养育子女，才能没有那么多局促</p>
<h3 id="婚姻阶段"><a href="#婚姻阶段" class="headerlink" title="婚姻阶段"></a>婚姻阶段</h3><p>何时结婚，大部分人在很年轻的时候就结婚，然后离婚再婚，有些着是比较晚结婚，有人婚内出轨，看你如何经营婚姻，好的婚姻两个人互相滋养，坏的互相消耗，两个如何相处，日常琐事如何处理。</p>
<h3 id="养育子女阶段"><a href="#养育子女阶段" class="headerlink" title="养育子女阶段"></a>养育子女阶段</h3><p>生育几个孩子，如何培养孩子，如何跟子女相处，有的人离婚自己养育孩子，有的人生一大堆孩子然后离婚，子女生活遇到一些问题，如何分担</p>
<h2 id="从个人里看英国发展"><a href="#从个人里看英国发展" class="headerlink" title="从个人里看英国发展"></a>从个人里看英国发展</h2><p>整体国力在下降，面临就业岗位减少，很多人找不到工作。<br>私立教育与公立教育差异很大，有钱人就读私立更好的资源，加剧阶级分化。<br>离婚情况比较多，癌症概率很大。<br>种族问题。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/人文/">人文</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/感悟/">感悟</a><a href="/tags/纪录片/">纪录片</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/04/21/arts-2019-04-21-review/" title="Fallacies of Distributed Computing Explained 学习笔记" itemprop="url">Fallacies of Distributed Computing Explained 学习笔记</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-04-21T07:49:07.000Z" itemprop="datePublished"> Published 2019-04-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>阅读 8个分布式系统的谬误</p>
<ol>
<li>The network is reliable.</li>
<li>Latency is zero.</li>
<li>Bandwidth is infinite.</li>
<li>The network is secure.</li>
<li>Topology doesn’t change.</li>
<li>There is one administrator. </li>
<li>Transport cost is zero.</li>
<li>The network is homogeneous.</li>
</ol>
<p>阅读了1遍发现没什么深刻的印象，私自总结一下，<br>首先分布式网络是不可靠的，不安全的，异构的，拓扑是可能改变的，传输消耗不是0，延迟不是0，带宽不是无限的，主要分布在网络上，<br>在非分布式网络下，情况可能是单一的，特殊的，但扩散到分布式下，网络的各种情况都会遇到，所以不能轻易假设，网络是我们预期的那样简单。<br>其他事管理员可能不止一个人。</p>
<p>分布式就是要考虑各种各样的网络特殊情况，防止这些疏忽导致的系统异常。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/英语原文/">英语原文</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/分布式/">分布式</a><a href="/tags/架构/">架构</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/04/21/arts-2019-04-21-share/" title="关于这段时间学习的分析" itemprop="url">关于这段时间学习的分析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-04-21T07:49:07.000Z" itemprop="datePublished"> Published 2019-04-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>这段时间在以阿里的标准去复习，发现自己之前真的很多不会的。基础的集合类从来没想过要了解它的实现，不知道实现就不知道它的限制，这样是不可能使用好的。虚拟机没有看过，当时觉得虚拟机太复杂，还没腾出时间去看。并发没有好好研究，它和虚拟机一样也是认为它太难了。算法，数据结构也是，一直认为它很重要，但遇到点困难就退缩了，回到舒适区。这些困难可能暂时不会影响到那时的我，所以我也没有太在意，虽然他们都在，也都知道，但重要性没有那么高。</p>
<p>最近再把这些知识作为必须要学会的内容去学习，开头很难，制定计划内心都是拒绝的，开始1-2个星期，1天只能坐1-2道算法题，那个时候内心是崩溃的，但过了1-2个月，发现情况出现好转，每天做题的速度慢慢上来了。虽然并发还是不怎么会，但通过订阅别人的专栏，我发现，一开始不会的时候，知识的凌乱的，但通过师傅寻找内在的逻辑，精心编怕，你可以找到秩序，把混乱变成有序，需要付出努力，自然界是熵增的。<strong>学习就是这样一个过程， 把无序变成有序。</strong></p>
<p>从我女朋友学编程这件事来说，我一直想教她，但我理不出头绪，一般就是扔一本书给她，或者开头热教她一下，但过不了1个星期就不继续了，这是我没有吃透的表现，没有从混乱转变成有序，也不能将这种有序传授给别人。李笑来之前就说他口头教会别人游泳，说明功力很深厚，我也尝试教女朋友，模仿我学习的过程，但效果一般，我没有掌握好各种过渡的阶段，无法有效的表达。很多时候就是这样，明明自己会，但你不敢说会，因为你不能教会别人。<strong>以教为学</strong>很重要。</p>
<p>最近也体会到一个人意志坚定的重要性，认准一个道理，身边的不同人会给你不同的压力，顶住压力，你就能突破自我，完成进化。屈从压力，你可能会继续随波逐流，活在别人的阴影中，别人的意志里。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/人文/">人文</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/感悟/">感悟</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/04/21/arts-2019-04-21-algorithm/" title="删除二叉搜索树中的节点" itemprop="url">删除二叉搜索树中的节点</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-04-21T05:13:07.000Z" itemprop="datePublished"> Published 2019-04-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。<br>一般来说，删除节点可分为两个步骤：</p>
<ol>
<li>首先找到需要删除的节点；</li>
<li>如果找到了，删除它。<br>说明： 要求算法时间复杂度为 O(h)，h 为树的高度。<br>示例:<br>root = [5,3,6,2,4,null,7]<br>key = 3<br> 5<br>/ \<br>3   6<br>/ \   \<br>2   4   7<br>给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。<br>一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。<br> 5<br>/ \<br>4   6<br>/     \<br>2       7<br>另一个正确答案是 [5,2,6,null,4,null,7]。<br> 5<br>/ \<br>2   6<br>\   \<br> 4   7</li>
</ol>
<h2 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h2><p>分几种情况<br>1.没有左右子树，直接删除<br>2.只有一个子树，将父指向子，直接删除<br>3.如果是有父子节点，找到右子树最小的节点，替换</p>
<h3 id="犯错点"><a href="#犯错点" class="headerlink" title="犯错点"></a>犯错点</h3><p>1.只有一个元素的时候，删除没考虑好<br>2.删除根节点没有处理好</p>
<h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><p>参考别人的算法，自己在后面处理没写好，别人的算法是通过递归的，主要好处就不用找父节点了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode deleteNode(TreeNode root, int key) &#123;</span><br><span class="line">        if(root == null)return null;</span><br><span class="line">        if(root.val &gt; key)&#123;</span><br><span class="line">            root.left =  deleteNode(root.left, key);</span><br><span class="line">            return root;</span><br><span class="line">        &#125;else if(root.val &lt; key)&#123;</span><br><span class="line">            root.right = deleteNode(root.right, key);</span><br><span class="line">            return root;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(root.left == null)&#123;</span><br><span class="line">                return root.right;</span><br><span class="line">            &#125;else if(root.right == null)&#123;</span><br><span class="line">                return root.left;</span><br><span class="line">            &#125;else&#123;           </span><br><span class="line">                TreeNode successor = minNode(root.right);   </span><br><span class="line">                successor.right = deleteMin(root.right);</span><br><span class="line">                successor.left = root.left;</span><br><span class="line">                return successor;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private TreeNode minNode(TreeNode node)&#123;</span><br><span class="line">        if(node.left == null)&#123;          </span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">        return minNode(node.left);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    private TreeNode deleteMin(TreeNode node)&#123;</span><br><span class="line">        if(node.left == null)&#123;</span><br><span class="line">            return node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        node.left =  deleteMin(node.left);   </span><br><span class="line">        return node;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过递归的方式<br>1.如果node值大于 key，则递归左子树，返回值覆给左子树<br>2.如果node值小于key，则递归右子树，返回值覆给右子树<br>3.相等情况比较复杂<br>3.1 如果node值等于key，并且左子树为空，那么直接返回右子树，这样就删除了该node。<br>3.2 如果node值等于key，并且右子树为空，那么直接返回右子树，这样就删除了该node。<br>3.3 如果node等于key，同时左右都不为空<br>3.3.1 获取该子树最小的node，命名为successor<br>3.3.2 将右子树删除最小值，并且将最新的右子树赋值给successor的右子树<br>3.3.3 将之前节点的左子树赋值给successor的左子树<br>3.3.4 返回新构建的节点</p>
<p>minNode是返回某个子树的最小值，也就是找最左节点</p>
<p>deleteMin是删除子树的最小值，递归的方式<br>退出条件是某个节点的左节点是空，则返回右节点，其他情况递归左子树</p>
<p>主要使用了递归的手段， 这种手段可以避免找父节点，但我还不是很熟悉，需要继续熟悉递归的思维方式。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/leetcode/">leetcode</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/算法/">算法</a><a href="/tags/二叉树/">二叉树</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/04/19/arts-2019-4-21-tip/" title="java集合-CopyOnWriteArrayList" itemprop="url">java集合-CopyOnWriteArrayList</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-04-19T01:56:07.000Z" itemprop="datePublished"> Published 2019-04-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>实现List<e>, RandomAccess, Cloneable, java.io.Serializable 接口</e></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/** The lock protecting all mutators */</span><br><span class="line"> final transient ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line"> /** The array, accessed only via getArray/setArray. */</span><br><span class="line"> private transient volatile Object[] array;</span><br></pre></td></tr></table></figure>
<p>主要的成员变量有2个，一个ReentrantLock，一个是内部存值的数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Appends the specified element to the end of this list.</span><br><span class="line"> *</span><br><span class="line"> * @param e element to be appended to this list</span><br><span class="line"> * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;)</span><br><span class="line"> */</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        int len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + 1);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Add方法，先是前后两个lock与unlock，保证安全性。<br>实现实际上是复制一个原来数组，将新值添加到新数组的最后一位，内部变量指向新的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static final class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123;</span><br><span class="line">    /** Snapshot of the array */</span><br><span class="line">    private final Object[] snapshot;</span><br><span class="line">    /** Index of element to be returned by subsequent call to next.  */</span><br><span class="line">    private int cursor;</span><br><span class="line"></span><br><span class="line">    private COWIterator(Object[] elements, int initialCursor) &#123;</span><br><span class="line">        cursor = initialCursor;</span><br><span class="line">        snapshot = elements;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>内部的遍历，其实是将原来数组进行一个快照，这样即使数组变化了，不影响快照的遍历。</p>
<p>CopyOnWriteArrayList 的添加元素很消耗资源，因为每次都要新建一个数组，然后复制所有数据，只适用于读远大于写的情况，如果写比较多，性能会很差。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/后端/">后端</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/编程技巧/">编程技巧</a><a href="/tags/java/">java</a><a href="/tags/集合/">集合</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/04/14/arts-2019-04-14-review/" title="An introduction to distributed systems 学习笔记2" itemprop="url">An introduction to distributed systems 学习笔记2</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-04-14T08:30:07.000Z" itemprop="datePublished"> Published 2019-04-14</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>原文地址：<a href="https://github.com/aphyr/distsys-class" target="_blank" rel="noopener">https://github.com/aphyr/distsys-class</a></p>
<p>这周没怎么看，周末临时抱佛脚看了看。<br>还是关注广度，跟其他的分布式介绍对比了一下。一部分是知道为什么会需要分布式，接着两个主要方面就是扩展性和可用性。<br>应该主要3方面，高可用，高性能，高扩展性。<br>理解清楚CAP，从理论上清楚。<br>然后就是具体的每个方面，不同的实际技术。东西很多，但要把握脉络。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/英语原文/">英语原文</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/分布式/">分布式</a><a href="/tags/架构/">架构</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/04/14/arts-2019-04-14-share/" title="《7up》第二遍观后感2" itemprop="url">《7up》第二遍观后感2</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-04-14T07:32:07.000Z" itemprop="datePublished"> Published 2019-04-14</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="打算从事什么工作"><a href="#打算从事什么工作" class="headerlink" title="打算从事什么工作"></a>打算从事什么工作</h2><p>大部分人在21岁的时候很迷茫，接下来要从学生时代到工作了，多少有些不知所措，如果你从来没想过，规划过，更是如此。<br>如果能提前想好阶段，即使时间不固定，也能更好的处理接下来的变化，而不是随波逐流。<br>自然界的事物都是符合熵增的，就是不断的变得更混乱，只有人为的注入的能量，才能有秩序。比如nick说的那句话，只有不断努力才能维持停滞不前，只有突破自己，才能进行改变。</p>
<h2 id="你对政治的看法"><a href="#你对政治的看法" class="headerlink" title="你对政治的看法"></a>你对政治的看法</h2><p>要关心社会的发展，历史的进程，虽然自己很努力，但如果一个东西被历史淘汰，你再努力也是白费，比如林赛后面干了很久的图书馆，被强制淘汰了，这个不是她的错，但社会淘汰了你。</p>
<h2 id="未来你害怕什么"><a href="#未来你害怕什么" class="headerlink" title="未来你害怕什么"></a>未来你害怕什么</h2><p>知道自己的边界，自己的短板很重要</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/人文/">人文</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/感悟/">感悟</a><a href="/tags/纪录片/">纪录片</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/2/"><span></span>Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Java语言基础/" title="Java语言基础">Java语言基础<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Spring/" title="Spring">Spring<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/leetcode/" title="leetcode">leetcode<sup>11</sup></a></li>
		  
		
		  
			<li><a href="/categories/人文/" title="人文">人文<sup>12</sup></a></li>
		  
		
		  
			<li><a href="/categories/前端/" title="前端">前端<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/后端/" title="后端">后端<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/成长/" title="成长">成长<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/树莓派/" title="树莓派">树莓派<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/监控/" title="监控">监控<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/英语原文/" title="英语原文">英语原文<sup>8</sup></a></li>
		  
		
		  
			<li><a href="/categories/闲谈/" title="闲谈">闲谈<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/感悟/" title="感悟">感悟<sup>12</sup></a></li>
			
		
			
				<li><a href="/tags/编程技巧/" title="编程技巧">编程技巧<sup>12</sup></a></li>
			
		
			
				<li><a href="/tags/算法/" title="算法">算法<sup>11</sup></a></li>
			
		
			
				<li><a href="/tags/java/" title="java">java<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/分布式/" title="分布式">分布式<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/架构/" title="架构">架构<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/纪录片/" title="纪录片">纪录片<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/并发集合/" title="并发集合">并发集合<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/集合/" title="集合">集合<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/vue/" title="vue">vue<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Java/" title="Java">Java<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Trie树/" title="Trie树">Trie树<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/吴军/" title="吴军">吴军<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/二叉树/" title="二叉树">二叉树<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/堆/" title="堆">堆<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/图/" title="图">图<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/二分查找/" title="二分查找">二分查找<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/锁/" title="锁">锁<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Annotation/" title="Annotation">Annotation<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/链表/" title="链表">链表<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Larry Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2019 
		
		<a href="/about" target="_blank" title="R_Richie">R_Richie</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
