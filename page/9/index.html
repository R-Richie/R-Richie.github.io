
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>演练场</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="R_Richie">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="演练场">
<meta property="og:url" content="http://yoursite.com/page/9/index.html">
<meta property="og:site_name" content="演练场">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="演练场">

    
    <link rel="alternative" href="/atom.xml" title="演练场" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="演练场" title="演练场"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="演练场">演练场</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/05/18/arts-2019-05-18-algorithm2/" title="211.添加与搜索单词 - 数据结构设计" itemprop="url">211.添加与搜索单词 - 数据结构设计</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-05-18T14:18:07.000Z" itemprop="datePublished"> Published 2019-05-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>设计一个支持以下两种操作的数据结构：<br>void addWord(word)<br>bool search(word)<br>search(word) 可以搜索文字或正则表达式字符串，字符串只包含字母 . 或 a-z 。 . 可以表示任何一个字母。<br>示例:<br>addWord(“bad”)<br>addWord(“dad”)<br>addWord(“mad”)<br>search(“pad”) -&gt; false<br>search(“bad”) -&gt; true<br>search(“.ad”) -&gt; true<br>search(“b..”) -&gt; true<br>说明:<br>你可以假设所有单词都是由小写字母 a-z 组成的。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>用字典树可以解决，关键问题是.如何解决<br>我第一时间想到递归，遇到。要遍历整个子字符数组，<br>有一个递归标志符，表示已经匹配，这个标志符成功则返回，写的很乱，自己都懵逼<br>如何是. 就深度遍历，如果不是就匹配<br>结束条件，不匹配或到结尾，最后匹配是不是有结束符号<br>分两个2情况，一种是。，深度遍历，一种是具体值，走字典树<br>递归结束时index到数组结尾，返回结束标示符，需要空数组也返回false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">class WordDictionary &#123;</span><br><span class="line">    private TreeNode root;</span><br><span class="line">    public static class TreeNode&#123;</span><br><span class="line">        private char data;</span><br><span class="line">        private TreeNode[] child = new TreeNode[26];</span><br><span class="line">        private boolean isEndingChar = false;</span><br><span class="line">        public TreeNode(char data)&#123;</span><br><span class="line">            this.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">    public WordDictionary() &#123;</span><br><span class="line">        root = new TreeNode(&apos;/&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Adds a word into the data structure. */</span><br><span class="line">    public void addWord(String word) &#123;</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        char[] array = word.toCharArray();</span><br><span class="line">        for(int i = 0 ;i &lt; array.length ; i++)&#123;</span><br><span class="line">            int index = array[i] - &apos;a&apos;;</span><br><span class="line">            if(node.child[index] == null)&#123;</span><br><span class="line">                node.child[index] = new TreeNode(array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.child[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEndingChar = true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Returns if the word is in the data structure. A word could contain the dot character &apos;.&apos; to represent any one letter. */</span><br><span class="line">    public boolean search(String word) &#123;</span><br><span class="line">        if(word == null || word.length() == 0)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        char[] array = word.toCharArray();</span><br><span class="line">        return helper(array,0,node);       </span><br><span class="line">    &#125;</span><br><span class="line">    public boolean helper(char[] array,int index,TreeNode node)&#123;</span><br><span class="line">        if(index == array.length)&#123;</span><br><span class="line">            return node.isEndingChar;</span><br><span class="line">        &#125;        </span><br><span class="line">        char data = array[index];</span><br><span class="line">        </span><br><span class="line">        if(data == &apos;.&apos;)&#123; </span><br><span class="line">            TreeNode[] child = node.child;          </span><br><span class="line">            for(int i = 0 ; i&lt; child.length ; i++)&#123;</span><br><span class="line">                </span><br><span class="line">                if(child[i] != null &amp;&amp; helper(array, index+1, child[i]))&#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            int num = data - &apos;a&apos;;</span><br><span class="line">            if(node.child[num] == null)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;           </span><br><span class="line">            return helper(array,index+1, node.child[num]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your WordDictionary object will be instantiated and called as such:</span><br><span class="line"> * WordDictionary obj = new WordDictionary();</span><br><span class="line"> * obj.addWord(word);</span><br><span class="line"> * boolean param_2 = obj.search(word);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/leetcode/">leetcode</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/算法/">算法</a><a href="/tags/Trie树/">Trie树</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/05/18/arts-2019-05-18-tip2/" title="Java并发集合-LinkedBlockingQueue" itemprop="url">Java并发集合-LinkedBlockingQueue</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-05-18T14:18:00.000Z" itemprop="datePublished"> Published 2019-05-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>基于链表的有界阻塞队列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Linked list node class</span><br><span class="line"> */</span><br><span class="line">static class Node&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * One of:</span><br><span class="line">     * - the real successor Node</span><br><span class="line">     * - this Node, meaning the successor is head.next</span><br><span class="line">     * - null, meaning there is no successor (this is the last node)</span><br><span class="line">     */</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(E x) &#123; item = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于单链表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/** The capacity bound, or Integer.MAX_VALUE if none */</span><br><span class="line">private final int capacity;</span><br><span class="line"></span><br><span class="line">/** Current number of elements */</span><br><span class="line">private final AtomicInteger count = new AtomicInteger();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Head of linked list.</span><br><span class="line"> * Invariant: head.item == null</span><br><span class="line"> */</span><br><span class="line">transient Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Tail of linked list.</span><br><span class="line"> * Invariant: last.next == null</span><br><span class="line"> */</span><br><span class="line">private transient Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">/** Lock held by take, poll, etc */</span><br><span class="line">private final ReentrantLock takeLock = new ReentrantLock();</span><br><span class="line">/** Wait queue for waiting takes */</span><br><span class="line">private final Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">/** Lock held by put, offer, etc */</span><br><span class="line">private final ReentrantLock putLock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">/** Wait queue for waiting puts */</span><br><span class="line">private final Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure>
<p>capacity是用于记录容量 ，首尾两个指针，head和last。基于2个锁，一个takeLock锁，notEmpty条件变量，在空时候用。一个putLock锁，notFull条件变量，在满的时候用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Creates a &#123;@code LinkedBlockingQueue&#125; with a capacity of</span><br><span class="line"> * &#123;@link Integer#MAX_VALUE&#125;.</span><br><span class="line"> */</span><br><span class="line">public LinkedBlockingQueue() &#123;</span><br><span class="line">    this(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Creates a &#123;@code LinkedBlockingQueue&#125; with the given (fixed) capacity.</span><br><span class="line"> *</span><br><span class="line"> * @param capacity the capacity of this queue</span><br><span class="line"> * @throws IllegalArgumentException if &#123;@code capacity&#125; is not greater</span><br><span class="line"> *         than zero</span><br><span class="line"> */</span><br><span class="line">public LinkedBlockingQueue(int capacity) &#123;</span><br><span class="line">    if (capacity &lt;= 0) throw new IllegalArgumentException();</span><br><span class="line">    this.capacity = capacity;</span><br><span class="line">    last = head = new Node&lt;E&gt;(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化可以赋值容量，新建哨兵头指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Inserts the specified element at the tail of this queue, waiting if</span><br><span class="line"> * necessary for space to become available.</span><br><span class="line"> *</span><br><span class="line"> * @throws InterruptedException &#123;@inheritDoc&#125;</span><br><span class="line"> * @throws NullPointerException &#123;@inheritDoc&#125;</span><br><span class="line"> */</span><br><span class="line">public void put(E e) throws InterruptedException &#123;</span><br><span class="line">    if (e == null) throw new NullPointerException();</span><br><span class="line">    // Note: convention in all put/take/etc is to preset local var</span><br><span class="line">    // holding count negative to indicate failure unless set.</span><br><span class="line">    int c = -1;</span><br><span class="line">    Node&lt;E&gt; node = new Node&lt;E&gt;(e);</span><br><span class="line">    final ReentrantLock putLock = this.putLock;</span><br><span class="line">    final AtomicInteger count = this.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        /*</span><br><span class="line">         * Note that count is used in wait guard even though it is</span><br><span class="line">         * not protected by lock. This works because count can</span><br><span class="line">         * only decrease at this point (all other puts are shut</span><br><span class="line">         * out by lock), and we (or some other waiting put) are</span><br><span class="line">         * signalled if it ever changes from capacity. Similarly</span><br><span class="line">         * for all other uses of count in other wait guards.</span><br><span class="line">         */</span><br><span class="line">        while (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(node);</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        if (c + 1 &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    if (c == 0)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * Links node at end of queue.</span><br><span class="line"> *</span><br><span class="line"> * @param node the node</span><br><span class="line"> */</span><br><span class="line">private void enqueue(Node&lt;E&gt; node) &#123;</span><br><span class="line">    // assert putLock.isHeldByCurrentThread();</span><br><span class="line">    // assert last.next == null;</span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果队列容量等于最大容量，线程要在notFull 条件变量下等待。<br>如果没满，就调用enqueue，进行入站。<br>如果添加队列后小于容量，就在notFull里唤醒一个线程。<br>这里面使用putLock进行加锁，不影响出站。<br>由于是2个锁，只有在容量空的时候，才会去唤醒takeLock的notEmpty等待队列。<br>使用的模型与一个锁的不同，2个锁的模型，需要通过原子操作的count来判断是不是唤醒，小于容量就可以唤醒notFull等待队列，最后如果容量等于0，就去takeLock的锁去唤醒notEmpty等待队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">    E x;</span><br><span class="line">    int c = -1;</span><br><span class="line">    final AtomicInteger count = this.count;</span><br><span class="line">    final ReentrantLock takeLock = this.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (count.get() == 0) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        if (c &gt; 1)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    if (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * Removes a node from head of queue.</span><br><span class="line"> *</span><br><span class="line"> * @return the node</span><br><span class="line"> */</span><br><span class="line">private E dequeue() &#123;</span><br><span class="line">    // assert takeLock.isHeldByCurrentThread();</span><br><span class="line">    // assert head.item == null;</span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    h.next = h; // help GC</span><br><span class="line">    head = first;</span><br><span class="line">    E x = first.item;</span><br><span class="line">    first.item = null;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出队列，与入队列思路相同，使用takeLock锁，如果count为0，就进入notEmpty队列等待。<br>dequeue就是将头删除，原来的first元素，变成哨兵指针。<br>如果count 大于1还可以继续take，唤醒notEmpty队列的线程。最后如果修改之前count等于容量，唤醒notFull队列，还可以put。<br>offer和poll和put和take原理相同，只是他们不是阻塞的，直接返回布尔值。</p>
<p>总结：基于单链表的阻塞单端队列，入队出队2个独立的锁，通过原子操作count，来处理状态。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/后端/">后端</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/java/">java</a><a href="/tags/编程技巧/">编程技巧</a><a href="/tags/并发集合/">并发集合</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/05/18/arts-2019-05-18-algorithm1/" title="208.实现 Trie (前缀树)" itemprop="url">208.实现 Trie (前缀树)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-05-18T14:17:07.000Z" itemprop="datePublished"> Published 2019-05-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。<br>示例:<br>Trie trie = new Trie();<br>trie.insert(“apple”);<br>trie.search(“apple”);   // 返回 true<br>trie.search(“app”);     // 返回 false<br>trie.startsWith(“app”); // 返回 true<br>trie.insert(“app”);<br>trie.search(“app”);     // 返回 true<br>说明:<br>你可以假设所有的输入都是由小写字母 a-z 构成的。<br>保证所有输入均为非空字符串。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>开始是root不存储数据<br>然后引入一个小写字母数组<br>每个数组里面的对象包含自己和数组还有是否是叶子结点<br>内部类 TreeNode，包含字符，TreeNode数组，叶子结点标示<br>每次一个字符，一次遍历查下去<br>abcde fghij klmno pqrst uvwxy z<br>字符数组的大小一直错<br>Trie树的实现<br>插入没有就新建，有的继续遍历<br>搜索跟新建相似，最后介绍不是叶子结点就返回false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">class Trie &#123;</span><br><span class="line">    private TreeNode root;</span><br><span class="line">    public static class TreeNode&#123;</span><br><span class="line">        private char data;</span><br><span class="line">        private TreeNode[] child = new TreeNode[26];</span><br><span class="line">        private boolean isEndingChar = false;</span><br><span class="line">        public TreeNode(char data)&#123;</span><br><span class="line">            this.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">    public Trie() &#123;</span><br><span class="line">        root = new TreeNode(&apos;/&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Inserts a word into the trie. */</span><br><span class="line">    public void insert(String word) &#123;</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        char[] array = word.toCharArray();</span><br><span class="line">        for(int i = 0 ; i &lt; array.length ; i++)&#123;</span><br><span class="line">            int index = array[i] - &apos;a&apos;;</span><br><span class="line">            if(node.child[index] == null)&#123;</span><br><span class="line">                node.child[index] = new TreeNode(array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.child[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEndingChar = true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Returns if the word is in the trie. */</span><br><span class="line">    public boolean search(String word) &#123;</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        char[] array = word.toCharArray();</span><br><span class="line">        for(int i = 0 ; i &lt; array.length ; i++)&#123;</span><br><span class="line">            int index = array[i] - &apos;a&apos;;</span><br><span class="line">            if(node.child[index] == null)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.child[index];</span><br><span class="line">        &#125;</span><br><span class="line">        if(!node.isEndingChar)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Returns if there is any word in the trie that starts with the given prefix. */</span><br><span class="line">    public boolean startsWith(String prefix) &#123;</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        char[] array = prefix.toCharArray();</span><br><span class="line">        for(int i = 0 ; i &lt; array.length ; i++)&#123;</span><br><span class="line">            int index = array[i] - &apos;a&apos;;</span><br><span class="line">            if(node.child[index] == null)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.child[index];</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your Trie object will be instantiated and called as such:</span><br><span class="line"> * Trie obj = new Trie();</span><br><span class="line"> * obj.insert(word);</span><br><span class="line"> * boolean param_2 = obj.search(word);</span><br><span class="line"> * boolean param_3 = obj.startsWith(prefix);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/leetcode/">leetcode</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/算法/">算法</a><a href="/tags/Trie树/">Trie树</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/05/18/arts-2019-05-18-tip1/" title="Java并发集合-DelayQueue" itemprop="url">Java并发集合-DelayQueue</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-05-18T14:14:00.000Z" itemprop="datePublished"> Published 2019-05-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>基于优先级队列的无界队列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Creates a new &#123;@code DelayQueue&#125; that is initially empty.</span><br><span class="line"> */</span><br><span class="line">public DelayQueue() &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>构造器为空</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private final transient ReentrantLock lock = new ReentrantLock();</span><br><span class="line">private final PriorityQueue&lt;E&gt; q = new PriorityQueue&lt;E&gt;();</span><br><span class="line">private Thread leader = null;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Condition signalled when a newer element becomes available</span><br><span class="line"> * at the head of the queue or a new thread may need to</span><br><span class="line"> * become leader.</span><br><span class="line"> */</span><br><span class="line">private final Condition available = lock.newCondition();</span><br></pre></td></tr></table></figure>
<p>一个内部的锁，一个存储用的优先级队列，存储对象E，要继承Delayed，一个leader用于当前优先级最高要执行的线程。available用于等待的线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Inserts the specified element into this delay queue.</span><br><span class="line"> *</span><br><span class="line"> * @param e the element to add</span><br><span class="line"> * @return &#123;@code true&#125;</span><br><span class="line"> * @throws NullPointerException if the specified element is null</span><br><span class="line"> */</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        q.offer(e);</span><br><span class="line">        if (q.peek() == e) &#123;</span><br><span class="line">            leader = null;</span><br><span class="line">            available.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要的插入的方法是offer，使用lock锁住，存取使用同一个锁，将新元素添加之前的优先级队列中，如果添加的新元素根据优先级排列在第一位，就要清空原来要执行leader线程，不然你没法作为优先级最好的去执行，然后随便唤醒一个线程就可以执行优先级最高的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Retrieves and removes the head of this queue, waiting if necessary</span><br><span class="line"> * until an element with an expired delay is available on this queue.</span><br><span class="line"> *</span><br><span class="line"> * @return the head of this queue</span><br><span class="line"> * @throws InterruptedException &#123;@inheritDoc&#125;</span><br><span class="line"> */</span><br><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            E first = q.peek();</span><br><span class="line">            if (first == null)</span><br><span class="line">                available.await();</span><br><span class="line">            else &#123;</span><br><span class="line">                long delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                if (delay &lt;= 0)</span><br><span class="line">                    return q.poll();</span><br><span class="line">                first = null; // don&apos;t retain ref while waiting</span><br><span class="line">                if (leader != null)</span><br><span class="line">                    available.await();</span><br><span class="line">                else &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        if (leader == thisThread)</span><br><span class="line">                            leader = null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (leader == null &amp;&amp; q.peek() != null)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Take是获取到时间的元素，不断自旋，进来先取出优先级队列的第一个，如果优先级队列是空，就在available变量里等待。<br>如果队列里有元素，就计算纳秒的延迟时间。如果这个时间小于0，就弹出元素，然后返回，这个是推出自旋的出口。<br>如果还没到延迟时间，就看leader是不是有值，代表只不是有其他正要执行的线程，如果有就等待，如果没有，就将当前线程作为执行线程，同时等待延迟时间，到时间后唤醒，重新自旋，判断是否退出。<br>这个主要问题就是插入优先级高于正要执行的当前线程，就需要重置leader重新判断哪个实现执行。<br>最后没有leader线程再执行，就再唤醒下一个available的等待线程<br>总结：基于优先级队列，需要自己继承Delay，实现比较、计算延迟时间的方法。通过等待与唤醒来按时间执行。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/后端/">后端</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/java/">java</a><a href="/tags/编程技巧/">编程技巧</a><a href="/tags/并发集合/">并发集合</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/05/18/arts-2019-05-18-share/" title="《7up》第二遍观后感4" itemprop="url">《7up》第二遍观后感4</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-05-18T14:07:01.000Z" itemprop="datePublished"> Published 2019-05-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><strong>回望每个人的一个个七年，提取出共性，每个人大致都会经历的事情，看人的一生的规律</strong></p>
<h2 id="人生的几个阶段"><a href="#人生的几个阶段" class="headerlink" title="人生的几个阶段"></a>人生的几个阶段</h2><p>原生家庭（父母是否离婚，单亲，与父母相处的时间）<br>教育（学校（付出金钱的程度），自己学习的态度）<br>工作（获得金钱是否足够生活，是否努力向上）<br>婚姻（多大年龄结婚，如何维系婚姻，离婚，再婚）<br>子女（是否要孩子，几个孩子，如何处理关系）<br>父母（去世，癌症，关系）<br>健康（疾病，生活质量）</p>
<hr>
<p><strong>俯瞰人生，看重要阶段见元素的关联关系，分析人生的关键点</strong></p>
<h2 id="重要阶段分析"><a href="#重要阶段分析" class="headerlink" title="重要阶段分析"></a>重要阶段分析</h2><p>人从出生开始就各不相同，家庭情况对于每个新生儿来说是随机的，不能选择的。<br>富裕的家庭的孩子比贫困的更加自信。单亲或父母离婚的比正常家庭的孩子，更没有安全感，缺乏自信。<br>好的教育可以改变一个人，富裕家庭的孩子可以接受更好的教育，比如读私立学校，读预科学校。贫穷家庭的孩子可能没意识到教育的重要性，需要更早的进入社会，去竞争生存。也可能通过教育，提升自己的维度，让自己跨越不同的阶级。<br>出生情况不能选择，但后面的人生可以选择，选择的前提是自己的见识。<br>见识的高度才是整个人生的高度，先天不足可以后天弥补，但如果不知道自己不足，那就会原地踏步。听到之前林赛说，她们三姐妹反而比富人的家的孩子选择更多，他们的人生已经固定，从7岁就被选择好了，她们可以自由的决定。一听起来好像很有道理，但这个是带有偏见的，富人家的孩子也是通过不断努力才达到父母预期的高度，不能否认他们自己的努力，并非一切从出生就安排好了，而是他们努力达到的比较高的目标。反而是林赛她们没有什么目标，好像可以自由选择，但都是漫无目的的原地踏步。<br>婚姻对一个人十分重要，好的婚姻二个人互相扶持，共同面对困难，共同承担责任。很多人当时结婚的时候并没有考虑清楚，只是正好到了年龄，决定应该结婚了。一些自我牺牲，换取团体的利益最大化，在不断磨合下，既能做自己，又能融洽相处。婚姻是一个集体，家庭也是一个集体，这个集体与外面的不太一样，是通过血缘与爱结合在一起。<br>子女出生，又是一个轮回，到了教育子女的问题了，大部分会将自己的遗憾投射到子女身上，希望她们比自己更好，不经历自己的痛苦，希望自己的孩子接受更好的教育，但也要跟自己经济实力匹配，父母一般会支出一条自己熟悉的路。<br>健康是无价之宝，一切的前提，得癌症的概率很高，没有几个健康的身体，生活的质量会明显下降。<br>死亡是每个人都必须面对的，父母、亲人的离世，自己的寿命到期，尽量多帮助别人，可以在多留下自己的生活过的痕迹。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/人文/">人文</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/感悟/">感悟</a><a href="/tags/纪录片/">纪录片</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/05/12/arts-2019-05-12-review/" title="Distributed Systems Principles and Paradigms 学习笔记2" itemprop="url">Distributed Systems Principles and Paradigms 学习笔记2</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-05-12T09:22:07.000Z" itemprop="datePublished"> Published 2019-05-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>这周读的也不多，只读了一节</p>
<p>第二节讲了分布式的架构，在谈论架构时，一个关键的想法是架构风格。 一种风格反映了组织包括分布式系统的软件组件之间的交互所遵循的基本原则。 重要的样式包括分层，面向对象，面向事件和数据中心方向。</p>
<p>分布式有很多组织结构，一种重要的模式切分服务器为访问端和服务器端。</p>
<p>客户端 - 服务器架构通常高度集中。 在分散的架构中，我们经常看到构成分布式系统的过程所起的平等作用，也称为点对点系统。 在对等系统中，进程被组织成覆盖网络，该覆盖网络是逻辑网络，其中每个进程具有可与其通信的其他对等体的本地列表。 可以构造覆盖网络，在这种情况下，可以部署确定性方案以在进程之间路由消息。 在非结构化网络中，对等体列表或多或少是随机的，这意味着需要部署搜索算法来定位数据或其他进程。</p>
<p>作为替代方案，已经开发了自我管理的分布式系统。 这些系统在某种程度上融合了系统和软件架构的想法。 自我管理系统通常可以组织为反馈控制循环。 这样的循环包含由分布式系统的行为测量的监视组件，用于查看是否需要调整任何内容的分析组件，以及用于改变行为的各种仪器的集合。 反馈控制循环可以集成到许多地方的分布式系统中。 在共同理解如何开发和部署这样的循环之前，仍然需要进行大量研究。</p>
<p>总结的翻译，这周看的时间很少，还没有找到分布式的线索。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/英语原文/">英语原文</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/分布式/">分布式</a><a href="/tags/架构/">架构</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/05/12/arts-2019-05-12-share/" title="《全球科技史纲》吴军-读后感1" itemprop="url">《全球科技史纲》吴军-读后感1</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-05-12T09:18:07.000Z" itemprop="datePublished"> Published 2019-05-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>之前在得到上听了一遍，今天又重新看书。书中使用2条线索穿起来整个科技史，能量与信息，真的很绝妙。相信没有理科思维的人是不会有这两种视角去看历史。从能量的角度看人类是怎么一步步进化，是不断获取更多的能量。信息的处理又能优化能量的使用。<br>之前的历史都是使用重大事件以及它产生的意义作为分割点，但这里从能量的角度去看，既新奇又合理，之前为什么没有想到。物理学是研究事物规律的，那里面的一些定律是不是会反映出一些，客观规律，也可以作为一些基础概念，理解其他事物。<br>还是比较好奇，吴军老师是怎么研究这些历史的，现在听得都是结果，如果我想自己去做研究，要从哪里获取资料，怎么去研究，怎么得到结论。吴军老师经常能拿一些我们之前熟悉的例子，通过一些不为人知的历史，来证明原来的是谣传。如何查看的资料，我很想知道。<br>很多史料都很有趣，比如人发明衣服的时间是通过体虱的进化时间的来，人类走出非洲的时间跟太阳的热量有关。人类从史前到定居，农耕，创建文明。<br><strong>分享一些基本方法论</strong><br>回望历史，把握历史进化的来龙去脉，可以清楚我们今天所处的位置；<br>俯瞰历史，把握所有要素之间的联系，可以看清世界变化的规律。<br>经典结论<br>历史总在重演，科技永远向前。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/人文/">人文</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/感悟/">感悟</a><a href="/tags/吴军/">吴军</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/05/11/arts-2019-05-12-tip/" title="java锁-CountDownLatch" itemprop="url">java锁-CountDownLatch</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-05-11T14:31:00.000Z" itemprop="datePublished"> Published 2019-05-11</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>内部类Sync继承AbstractQueuedSynchronizer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Synchronization control For CountDownLatch.</span><br><span class="line"> * Uses AQS state to represent count.</span><br><span class="line"> */</span><br><span class="line">private static final class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">    private static final long serialVersionUID = 4982264981922014374L;</span><br><span class="line"></span><br><span class="line">    Sync(int count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getCount() &#123;</span><br><span class="line">        return getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">        return (getState() == 0) ? 1 : -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">        // Decrement count; signal when transition to zero</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int c = getState();</span><br><span class="line">            if (c == 0)</span><br><span class="line">                return false;</span><br><span class="line">            int nextc = c-1;</span><br><span class="line">            if (compareAndSetState(c, nextc))</span><br><span class="line">                return nextc == 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过构造器传入state的数值。<br>tryAcquireShared 非独占加锁，实现如果state不是0，就返回-1，小于0。等于0，就返回1，大于0<br>tryReleaseShare 非独占解锁，自旋，如果状态等于0，就是解锁失败。每次解锁大小减1，如果等于0，则解锁成功，其他则失败</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public CountDownLatch(int count) &#123;</span><br><span class="line">    if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;);</span><br><span class="line">    this.sync = new Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造器传入count，赋值给state<br>添加await方法，用于加锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public void await() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line">private void doAcquireSharedInterruptibly(int arg)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    final Node node = addWaiter(Node.SHARED);</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            if (p == head) &#123;</span><br><span class="line">                int r = tryAcquireShared(arg);</span><br><span class="line">                if (r &gt;= 0) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除非state减为0，其他情况，tryAcquireShared都小于0，要进doAcquireSharedInterruptibly方法<br>doAcquireSharedInterruptibly方法，先非独占的加入队列，然后判断前序节点是不是头节点，<br>如果是前序节点是头节点，判断tryAcquireShared结果，在state减为0前，这个都是不进入r》=0的条件里，后面就会wait等待 前面执行完，后唤醒。<br>不断自旋，只有在前序是头节点，同时state是0 时，才会继续执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void countDown() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>countDown，每次减1，在每到0，之前返回都是false。</p>
<p>总结：基于模版AbstractQueuedSynchronizer，通过tryAcquireShared 加锁，countDown 不断减少state，直到等于0，再解锁，可以实现，单个线程等待其他多个线程的功能。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/后端/">后端</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/java/">java</a><a href="/tags/编程技巧/">编程技巧</a><a href="/tags/锁/">锁</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/05/05/arts-2019-05-05-review/" title="Distributed Systems Principles and Paradigms 学习笔记1" itemprop="url">Distributed Systems Principles and Paradigms 学习笔记1</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-05-05T08:22:07.000Z" itemprop="datePublished"> Published 2019-05-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>五一假期，学习时间比平时还要少，看得很少，先写一部分吧。</p>
<h2 id="分布式系统的定义"><a href="#分布式系统的定义" class="headerlink" title="分布式系统的定义"></a>分布式系统的定义</h2><p>A distributed system is a collection of independent computers that appears to its users as a single coherent system.<br>分布式系统是一堆独立的电脑的集合，使用者使用的像是单一系统一样。</p>
<h2 id="分布式系统的目标"><a href="#分布式系统的目标" class="headerlink" title="分布式系统的目标"></a>分布式系统的目标</h2><ol>
<li>Making Resources Accessible</li>
<li>Distribution Transparency</li>
<li>Openness</li>
<li>Scalability</li>
<li>Pitfalls</li>
</ol>
<p>第一个是让分散在各地的资源可以简单被访问。<br>第二个是分配透明度，隐藏资源分布在各地。<br>第三个是开放式分布式系统是根据标准规则提供服务的系统，这些规则描述了这些服务的语法和语义。<br>第四个是可扩展性<br>第五个是一些陷阱，7大分布式谬论</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/英语原文/">英语原文</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/分布式/">分布式</a><a href="/tags/架构/">架构</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/05/05/arts-2019-05-05-algorithm/" title="克隆图" itemprop="url">克隆图</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-05-05T03:42:07.000Z" itemprop="datePublished"> Published 2019-05-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定无向连通图中一个节点的引用，返回该图的深拷贝（克隆）。图中的每个节点都包含它的值&nbsp;val（Int） 和其邻居的列表（list[Node]）。<br>示例：<img src="evernotecid://BA9A3242-C386-4E68-A9D1-1193A9AF4350/appyinxiangcom/11402844/ENResource/p911" alt="7b2bfd1590ab9401ab6d2eb6d985b68a.png"><br>输入：{“$id”:”1”,”neighbors”:[{“$id”:”2”,”neighbors”:[{“$ref”:”1”},{“$id”:”3”,”neighbors”:[{“$ref”:”2”},{“$id”:”4”,”neighbors”:[{“$ref”:”3”},{“$ref”:”1”}],”val”:4}],”val”:3}],”val”:2},{“$ref”:”4”}],”val”:1}解释：节点 1 的值是 1，它有两个邻居：节点 2 和 4 。节点 2 的值是 2，它有两个邻居：节点 1 和 3 。节点 3 的值是 3，它有两个邻居：节点 2 和 4 。节点 4 的值是 4，它有两个邻居：节点 1 和 3 。提示：节点数介于 1 到 100 之间。无向图是一个简单图，这意味着图中没有重复的边，也没有自环。由于图是无向的，如果节点&nbsp;p&nbsp;是节点&nbsp;q&nbsp;的邻居，那么节点&nbsp;q&nbsp;也必须是节点&nbsp;p&nbsp;的邻居。必须将给定节点的拷贝作为对克隆图的引用返回。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>深度遍历+深浅克隆<br>Map用于存放访问过的点，如果访问过直接返回<br>递归遍历neighbors<br>结束条件是，所有节点都访问过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">// Definition for a Node.</span><br><span class="line">class Node &#123;</span><br><span class="line">    public int val;</span><br><span class="line">    public List&lt;Node&gt; neighbors;</span><br><span class="line"></span><br><span class="line">    public Node() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public Node(int _val,List&lt;Node&gt; _neighbors) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        neighbors = _neighbors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public Node cloneGraph(Node node) &#123;</span><br><span class="line">        Map&lt;Integer,Node&gt; map = new HashMap&lt;Integer,Node&gt;();</span><br><span class="line">        return deepClone(node,map);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Node deepClone(Node node,Map&lt;Integer,Node&gt; map)&#123;</span><br><span class="line">        Node newNode;</span><br><span class="line">        if(map.containsKey(node.val))&#123;</span><br><span class="line">            newNode = map.get(node.val);</span><br><span class="line">            return newNode;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            newNode = new Node(node.val,null);</span><br><span class="line">            map.put(node.val,newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Node&gt; nei = new ArrayList&lt;Node&gt;();</span><br><span class="line">        if(node.neighbors != null)&#123;</span><br><span class="line">            for(Node n : node.neighbors)&#123;</span><br><span class="line">                nei.add(deepClone(n,map));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode.neighbors = nei;</span><br><span class="line">        return newNode;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/leetcode/">leetcode</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/算法/">算法</a><a href="/tags/图/">图</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/8/"><span></span>Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/10/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Java语言基础/" title="Java语言基础">Java语言基础<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Spring/" title="Spring">Spring<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/leetcode/" title="leetcode">leetcode<sup>29</sup></a></li>
		  
		
		  
			<li><a href="/categories/人文/" title="人文">人文<sup>40</sup></a></li>
		  
		
		  
			<li><a href="/categories/前端/" title="前端">前端<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/后端/" title="后端">后端<sup>28</sup></a></li>
		  
		
		  
			<li><a href="/categories/成长/" title="成长">成长<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/树莓派/" title="树莓派">树莓派<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/监控/" title="监控">监控<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/英语原文/" title="英语原文">英语原文<sup>12</sup></a></li>
		  
		
		  
			<li><a href="/categories/英语技术文档/" title="英语技术文档">英语技术文档<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/闲谈/" title="闲谈">闲谈<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/感悟/" title="感悟">感悟<sup>40</sup></a></li>
			
		
			
				<li><a href="/tags/编程技巧/" title="编程技巧">编程技巧<sup>30</sup></a></li>
			
		
			
				<li><a href="/tags/算法/" title="算法">算法<sup>29</sup></a></li>
			
		
			
				<li><a href="/tags/java/" title="java">java<sup>18</sup></a></li>
			
		
			
				<li><a href="/tags/架构/" title="架构">架构<sup>13</sup></a></li>
			
		
			
				<li><a href="/tags/分布式/" title="分布式">分布式<sup>12</sup></a></li>
			
		
			
				<li><a href="/tags/计算机组成/" title="计算机组成">计算机组成<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/纪录片/" title="纪录片">纪录片<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/单元测试/" title="单元测试">单元测试<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/电视剧/" title="电视剧">电视剧<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/链表/" title="链表">链表<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/字符串/" title="字符串">字符串<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/Junit5/" title="Junit5">Junit5<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/动态规划/" title="动态规划">动态规划<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/并发集合/" title="并发集合">并发集合<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/集合/" title="集合">集合<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/数组/" title="数组">数组<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/历史/" title="历史">历史<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/学习方法/" title="学习方法">学习方法<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/树/" title="树">树<sup>2</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Larry Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2022 
		
		<a href="/about" target="_blank" title="R_Richie">R_Richie</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
