
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>演练场</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="R_Richie">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="演练场">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="演练场">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="演练场">

    
    <link rel="alternative" href="/atom.xml" title="演练场" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="演练场" title="演练场"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="演练场">演练场</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/04/14/arts-2019-04-14-review/" title="An introduction to distributed systems 学习笔记2" itemprop="url">An introduction to distributed systems 学习笔记2</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-04-14T08:30:07.000Z" itemprop="datePublished"> Published 2019-04-14</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>原文地址：<a href="https://github.com/aphyr/distsys-class" target="_blank" rel="noopener">https://github.com/aphyr/distsys-class</a></p>
<p>这周没怎么看，周末临时抱佛脚看了看。<br>还是关注广度，跟其他的分布式介绍对比了一下。一部分是知道为什么会需要分布式，接着两个主要方面就是扩展性和可用性。<br>应该主要3方面，高可用，高性能，高扩展性。<br>理解清楚CAP，从理论上清楚。<br>然后就是具体的每个方面，不同的实际技术。东西很多，但要把握脉络。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/英语原文/">英语原文</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/分布式/">分布式</a><a href="/tags/架构/">架构</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/04/14/arts-2019-04-14-share/" title="《7up》第二遍观后感2" itemprop="url">《7up》第二遍观后感2</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-04-14T07:32:07.000Z" itemprop="datePublished"> Published 2019-04-14</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="打算从事什么工作"><a href="#打算从事什么工作" class="headerlink" title="打算从事什么工作"></a>打算从事什么工作</h2><p>大部分人在21岁的时候很迷茫，接下来要从学生时代到工作了，多少有些不知所措，如果你从来没想过，规划过，更是如此。<br>如果能提前想好阶段，即使时间不固定，也能更好的处理接下来的变化，而不是随波逐流。<br>自然界的事物都是符合熵增的，就是不断的变得更混乱，只有人为的注入的能量，才能有秩序。比如nick说的那句话，只有不断努力才能维持停滞不前，只有突破自己，才能进行改变。</p>
<h2 id="你对政治的看法"><a href="#你对政治的看法" class="headerlink" title="你对政治的看法"></a>你对政治的看法</h2><p>要关心社会的发展，历史的进程，虽然自己很努力，但如果一个东西被历史淘汰，你再努力也是白费，比如林赛后面干了很久的图书馆，被强制淘汰了，这个不是她的错，但社会淘汰了你。</p>
<h2 id="未来你害怕什么"><a href="#未来你害怕什么" class="headerlink" title="未来你害怕什么"></a>未来你害怕什么</h2><p>知道自己的边界，自己的短板很重要</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/人文/">人文</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/感悟/">感悟</a><a href="/tags/纪录片/">纪录片</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/04/14/arts-2019-04-14-algorithm/" title="找到 K 个最接近的元素" itemprop="url">找到 K 个最接近的元素</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-04-14T05:13:07.000Z" itemprop="datePublished"> Published 2019-04-14</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个排序好的数组，两个整数 k 和 x，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。如果有两个数与 x 的差值一样，优先选择数值较小的那个数。<br>示例 1:<br>输入: [1,2,3,4,5], k=4, x=3<br>输出: [1,2,3,4]</p>
<p>示例 2:<br>输入: [1,2,3,4,5], k=4, x=-1<br>输出: [1,2,3,4]</p>
<p>说明:</p>
<ol>
<li>k 的值为正数，且总是小于给定排序数组的长度。</li>
<li>数组不为空，且长度不超过 104</li>
<li>数组里的每个元素与 x 的绝对值不超过 104</li>
</ol>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先这是一个有序的数组，那就可以先二分法查找x，然后返回对于的索引，这个分几种情况<br>1）找到等于x的值，直接返回索引<br>2）找不到具体等于x的值，就只能找到离x最近且最小的索引值</p>
<p>根据上面返回的索引值，作为第二步的初始索引。分别判断前后的是不是到上下边界了，<br>1）没到边界，分别找前后离x最近的边界，左或右移一位<br>2）到边界，只能反向移动，左移或右移动一位</p>
<p>结束条件是k，每次移动边界，k递减</p>
<h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"> public int binarySearch(int[] arr,int x)&#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = arr.length -1;</span><br><span class="line">        while(left &lt;= right)&#123;</span><br><span class="line">            int index = (right -left)/2+left;</span><br><span class="line">            int value = arr[index];</span><br><span class="line">            </span><br><span class="line">            if(value == x)&#123;</span><br><span class="line">                return index;</span><br><span class="line">            &#125;else if(value &gt; x)&#123;</span><br><span class="line">                right = index - 1;</span><br><span class="line">            &#125;else if(value &lt; x)&#123;</span><br><span class="line">                if(index + 1 &lt; (arr.length -1))&#123;</span><br><span class="line">                    int next = arr[index+1];</span><br><span class="line">                    if(next &lt; x)&#123;</span><br><span class="line">                        left = index + 1;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    int comp = (next - x) - (x - value);</span><br><span class="line">                    if(comp &gt;= 0)&#123;</span><br><span class="line">                        return index;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        return index+1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    return index;</span><br><span class="line">                &#125;</span><br><span class="line">                  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    public List&lt;Integer&gt; findClosestElements(int[] arr, int k, int x) &#123;</span><br><span class="line">        int flag = binarySearch(arr,x);</span><br><span class="line">        if(flag == -1)&#123;</span><br><span class="line">            List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">            for(int i = 0 ; i&lt;k;i++)&#123;</span><br><span class="line">                list.add(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            return list;</span><br><span class="line">        &#125;</span><br><span class="line">        int nums = k-1;</span><br><span class="line">        int left = flag;</span><br><span class="line">        int right = flag;</span><br><span class="line">        int size = arr.length;</span><br><span class="line">        while(nums != 0)&#123;</span><br><span class="line">            int innerLeft = left;</span><br><span class="line">            int innerRight = right;</span><br><span class="line">            if(right + 1 &gt; size -1)&#123;</span><br><span class="line">                left = innerLeft -1;</span><br><span class="line">                nums--;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;else if(left -1 &lt; 0)&#123;</span><br><span class="line">                right = innerRight + 1;</span><br><span class="line">                nums--;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if( right + 1 &lt;= size - 1 )&#123;</span><br><span class="line">                    innerRight = innerRight + 1;</span><br><span class="line">                &#125;</span><br><span class="line">                if(left -1 &gt;= 0)&#123;</span><br><span class="line">                    innerLeft = innerLeft -1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;        </span><br><span class="line">            int leftValue = arr[innerLeft];</span><br><span class="line">            int rightValue = arr[innerRight];</span><br><span class="line">            int leftDiv = x - leftValue;</span><br><span class="line">            int rightDiv = rightValue - x;</span><br><span class="line">            if(leftDiv &lt;= rightDiv)&#123;</span><br><span class="line">                left = innerLeft;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                right = innerRight;</span><br><span class="line">            &#125;           </span><br><span class="line">            nums--;       </span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list2 = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        for(int i = left ; i&lt;= right;i++)&#123;</span><br><span class="line">            list2.add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return list2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较容易出错的有几点<br>1.二分查找不光要找出等于的值，也要查找离的最近最小的值<br>2.第二次进行查询的时候，可能会有相等数字重复多次的情况，也要考虑<br>3.第二次查找，比较大小左右边界移动的判断条件很复杂，很容易出错。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/leetcode/">leetcode</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/算法/">算法</a><a href="/tags/二分查找/">二分查找</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/04/06/arts-2019-4-5-tip/" title="Vue 学习笔记2" itemprop="url">Vue 学习笔记2</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-04-06T07:13:07.000Z" itemprop="datePublished"> Published 2019-04-06</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>最近真的没有怎么实际写后端代码了，主要都是写一些简单的前端，而且不懂了也很少弄懂，真的很不好。<br>这周要分享的也很水，可以说算得上一个失败的经历。</p>
<p>在实现导航栏跳转的时候，类似视频网站多个tab切换，使用父子路由实现，子路由的页面几乎一直，所以css也差不多，因为都是全局的css，所以有些css重复了，我想做一个互相不影响的，隔离的css作用域，发现vue有一个scoped的概念，在style标签里加上scoped，编译的时候就会加上唯一的编号类似 class-123132，这样，那么就是全局唯一的了。<br>但是我尝试加上postcss，就和bootstrap-vue起了冲突，解决了一阵未果，没有继续尝试了。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/前端/">前端</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/vue/">vue</a><a href="/tags/编程技巧/">编程技巧</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/04/06/arts-2019-04-14-tips/" title="java集合-ArrayList" itemprop="url">java集合-ArrayList</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-04-06T07:13:07.000Z" itemprop="datePublished"> Published 2019-04-06</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>ArryList实现接口List<e>, RandomAccess, Cloneable, java.io.Serializable<br>基础的数据结构是数组，根据存储数据的多少动态扩容。</e></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Default initial capacity.</span><br><span class="line"> */</span><br><span class="line">private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Shared empty array instance used for empty instances.</span><br><span class="line"> */</span><br><span class="line">private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Shared empty array instance used for default sized empty instances. We</span><br><span class="line"> * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span><br><span class="line"> * first element is added.</span><br><span class="line"> */</span><br><span class="line">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The array buffer into which the elements of the ArrayList are stored.</span><br><span class="line"> * The capacity of the ArrayList is the length of this array buffer. Any</span><br><span class="line"> * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line"> * will be expanded to DEFAULT_CAPACITY when the first element is added.</span><br><span class="line"> */</span><br><span class="line">transient Object[] elementData</span><br><span class="line">/**</span><br><span class="line"> * The size of the ArrayList (the number of elements it contains).</span><br><span class="line"> *</span><br><span class="line"> * @serial</span><br><span class="line"> */</span><br><span class="line">private int size;</span><br></pre></td></tr></table></figure>
<p>elementData是实际存储数据的数组。DEFAULT_CAPACITY是默认的容量，如果没有指定数组的大小。DEFAULTCAPACITY_EMPTY_ELEMENTDATA 与EMPTY_ELEMENTDATA都是 空的初始数组，DEFAULTCAPACITY_EMPTY_ELEMENTDATA是用来判断是不是通过默认方法创建的空数组，而不是删除后才空的。如果指定了数组大小，就用EMPTY_ELEMENTDATA作为默认空数组。</p>
<p>扩容是在添加元素的时候进行，这样不会初始化没有数据的情况下就占据空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Appends the specified element to the end of this list.</span><br><span class="line"> *</span><br><span class="line"> * @param e element to be appended to this list</span><br><span class="line"> * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;)</span><br><span class="line"> */</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加方法很简单，先去内部扩容，然后在最后一个添加值，看扩容的内部实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * Increases the capacity to ensure that it can hold at least the</span><br><span class="line"> * number of elements specified by the minimum capacity argument.</span><br><span class="line"> *</span><br><span class="line"> * @param minCapacity the desired minimum capacity</span><br><span class="line"> */</span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    // minCapacity is usually close to size, so this is a win:</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ensureCapacityInternal 先是一个判断数组是怎么创建，如果是默认空参数的构造器创建，就使用默认的初始大小10作为最小容量，这样就能避免不能手动创建更小数组的问题。<br>主要扩容是grow方法，可以看出 newCapacity是扩容0.5倍大小，到原来的1.5倍。<br>还有就是容器上下限的判断。扩容就是迁移数组newCapacity的大小的数组里。<br>归根到底，就是将数组扩容1.5倍，旧数组搬迁到新数组。<br>里面还有几个内部类，一个Itr，实现了Iterator接口，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">    int cursor;       // index of next element to return</span><br><span class="line">    int lastRet = -1; // index of last element returned; -1 if no such</span><br><span class="line">    int expectedModCount = modCount;</span><br></pre></td></tr></table></figure></p>
<p>ListItr 实现了 ListIterator，可以前后访问遍历</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123;</span><br><span class="line">    ListItr(int index) &#123;</span><br><span class="line">        super();</span><br><span class="line">        cursor = index;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ArrayList使用遍历接口，都是使用内部类实现的，重新记录状态，这部分还有些不太懂的，后面继续补充。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/后端/">后端</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/编程技巧/">编程技巧</a><a href="/tags/java/">java</a><a href="/tags/集合/">集合</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/04/06/arts-2019-4-5-share/" title="《7up》第二遍观后感1" itemprop="url">《7up》第二遍观后感1</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-04-06T05:32:07.000Z" itemprop="datePublished"> Published 2019-04-06</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>第二遍重看这个纪录片，第一遍是初读的话，这一遍，我会比较细，记录记者的提问，不同人的不同答案。横向对比与之前7年的差别，以及为什么会有这样的变化。<br>这次只看了7岁和14岁的，第一次看感觉很粗略，有种震撼的感觉，但你不是能清楚说明白为什么。</p>
<p>先从记者提问入手</p>
<h2 id="旅游"><a href="#旅游" class="headerlink" title="旅游"></a>旅游</h2><p>穷人家的孩子没怎么出去过，富人家的孩子去过很多地方，这个确实是经济因素导致。穷人孩子连吃饭都不富足，想出去很难。开阔了眼界对于孩子认识世界很重要。</p>
<h2 id="放学后空闲时间做什么"><a href="#放学后空闲时间做什么" class="headerlink" title="放学后空闲时间做什么"></a>放学后空闲时间做什么</h2><p>7岁时候的问题，空闲时间对性格形成有很大的影响。<br>富人家的孩子学校有很多时间可以做，可以学音乐等。到了14岁，也是一样，富人家的孩子有很多事情做，一般人家没什么做，去玩或者去俱乐部，或者去看电视，消磨时间。<br>在自己意识下能去做一些事情，时间上利用会多很多，不会去看电视等消磨时间，常年累月下来就是产生很大的不同。</p>
<h2 id="怎么花钱，对于金钱的看法"><a href="#怎么花钱，对于金钱的看法" class="headerlink" title="怎么花钱，对于金钱的看法"></a>怎么花钱，对于金钱的看法</h2><p>John对于钱财的概念在14岁已经成熟了，不需要特别多的钱，但要足够能去做自己喜欢的事情，不能为了钱做无聊的工作。大部分人都表现不是很喜欢钱，认为钱够花就好了，这个时候他们还都没有赚钱，对于钱的需求感很弱，所以回答都很高尚，都没被贫穷困扰过。</p>
<p>对于我来说，现在真的很缺钱，不是生活上的缺钱，衣食住行都没问题，但房子特别贵，贵到不能承受，可能要背起20-30年的房贷，才能勉强买个40-50平的小房子。选工作上，如果工资高也会很动心，即使工作可能很累，重复没成长。也想自己出去赚钱，但能力有限，不能独立去市场上赚钱，还需要给别人打工。所以要有能赚足够多的钱的能力还是很重要的，有了钱很多事情都会轻松很多。做真正想做的事情。<br>要在主能力足够优秀的情况下，发展其他能力，但主的本身就不强的话，很难把其他发展很强。</p>
<h2 id="有男女朋友吗"><a href="#有男女朋友吗" class="headerlink" title="有男女朋友吗"></a>有男女朋友吗</h2><p>7岁的时候，大家都有男女朋友，但那个是很童真的。14岁的时候，大家都没有的真正的男女朋友，这个时候处于萌芽期。<br>多接触异性，对于后面的婚姻有帮助。</p>
<h2 id="对于罢工的看法，对于政党的看法"><a href="#对于罢工的看法，对于政党的看法" class="headerlink" title="对于罢工的看法，对于政党的看法"></a>对于罢工的看法，对于政党的看法</h2><p>14岁的时候，只有Join表现出了，想要从政的想法，对这方面很有见解，其他人都处于漠不关心的状态。<br>上层阶级反对罢工，下层人民接受罢工，虽然也觉得有影响，但两个层级的人的看法角度不相同，都是符合自己利益的角度。查尔斯能从自由的角度去看，罢工的意义，人民有罢工的权利<br><strong>人很难跳出自己的层级，自己的角度去看问题， 所以对一个问题认识的全面，要么需要经历，要么需要看不同层级的人是什么观点，是什么行为。</strong></p>
<h2 id="对于寄宿学校的看法"><a href="#对于寄宿学校的看法" class="headerlink" title="对于寄宿学校的看法"></a>对于寄宿学校的看法</h2><p>大部分人提到了会让人更独立，离开父母。但有人也提到了坏处，本应该跟父母相处，导致了部分的缺失。福利院的孩子在童年就缺失与父母的生活，整个人生中就缺少自信，在paul和symon身上体现很多。富人家的孩子更多的自信，穷人相对自卑。</p>
<h2 id="对于有钱人的看法"><a href="#对于有钱人的看法" class="headerlink" title="对于有钱人的看法"></a>对于有钱人的看法</h2><p>大家对于有钱人更多的是不好的看法，有钱人会欺负穷人，穷人嫉妒有钱人，他们一出生什么也不用做，就能达到他们一辈子工作的水平，很不公平。</p>
<h2 id="相信上帝吗"><a href="#相信上帝吗" class="headerlink" title="相信上帝吗"></a>相信上帝吗</h2><p>大部分人相信，但说不清楚原因，有的因为人总得有点信仰。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/人文/">人文</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/感悟/">感悟</a><a href="/tags/纪录片/">纪录片</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/04/05/arts-2019-4-5-review/" title="An introduction to distributed systems 学习笔记1" itemprop="url">An introduction to distributed systems 学习笔记1</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-04-05T13:06:07.000Z" itemprop="datePublished"> Published 2019-04-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>原文地址：<a href="https://github.com/aphyr/distsys-class" target="_blank" rel="noopener">https://github.com/aphyr/distsys-class</a></p>
<p>这篇文章相当于一个分布式学习的大纲，以我的3遍学习发来看，我这周只是通读了2遍，只达到了第一层级，那这周的文章就当作一个阅读大纲的提炼，先理清楚知识架构。分布式内容本身就十分多，如果不理清结构，很容易混乱，今天就是一个入门的开始。</p>
<ol>
<li>What makes a thing distributed</li>
<li>Nodes and networks</li>
<li>When networks go wrong</li>
<li>Low level protocols</li>
<li>Clocks</li>
</ol>
<p>Review<br>We’ve covered the fundamental primitives of distributed systems. Nodes exchange messages through a network, and both nodes and networks can fail in various ways. Protocols like TCP and UDP give us primitive channels for processes to communicate, and we can order events using clocks. Now, we’ll discuss some high-level properties of distributed systems.</p>
<hr>
<ol>
<li>Availability</li>
<li>Consistency</li>
<li>Tradeoffs</li>
</ol>
<p>Review<br>Availability is a measure of how often operations succeed. Consistency models are the rules that govern what operations can happen and when. Stronger consistency models generally come at the cost of performance and availability. Next, we’ll talk about different ways to build systems, from weak to strong consistency.</p>
<hr>
<ol>
<li>Avoid Consensus Wherever Possible</li>
<li>Fine, We Need Consensus, What Now?</li>
</ol>
<p>Review<br>Systems which only add facts, not retract them, require less coordination to build. We can use gossip systems to broadcast messages to other processes, CRDTs to merge updates from our peers, and HATs for weakly isolated transactions. Serializability and linearizability require consensus, which we can obtain through Paxos, ZAB, VR, or Raft. Now, we’ll talk about different scales of distributed systems.</p>
<hr>
<ol>
<li>Characteristic latencies</li>
</ol>
<p>Review<br>We discussed three characteristic scales for distributed systems: multicore processors coupled with a synchronous network, computers linked by a LAN, and datacenters linked by the internet or dedicated fiber. CPU consequences are largely performance concerns: knowing how to minimize coordination. On LANs, latencies are short enough for many network hops before users take notice. In geographically replicated systems, high latencies drive eventually consistent and datacenter-pinned solutions.</p>
<hr>
<ol>
<li>Common distributed systems</li>
</ol>
<p>Review<br>We use data structure stores as outsourced heaps: they’re the duct tape of distributed systems. KV stores and relational databases are commonly deployed as systems of record; KV stores use independent keys and are not well-suited to relational data, but offer improved scalability and partial failure vs SQL stores, which offer rich queries and strong transactional guarantees. Distributed search and coordination services round out our basic toolkit for building applications. Streaming systems are applied for continuous, low-latency processing of datasets, and tend to look more like frameworks than databases. Their dual, distributed queues, focus on the messages rather than the transformations.</p>
<hr>
<ol>
<li>A Pattern Language</li>
</ol>
<p>Review<br>When possible, try to use a single node instead of a distributed system. Accept that some failures are unavoidable: SLAs and apologies can be cost-effective. To handle catastrophic failure, we use backups. To improve reliability, we introduce redundancy. To scale to large problems, we divide the problem into shards. Immutable values are easy to store and cache, and can be referenced by mutable identities, allowing us to build strongly consistent systems at large scale. As software grows, different components must scale independently, and we break out libraries into distinct services. Service structure goes hand-in-hand with teams.</p>
<hr>
<ol>
<li>Production Concerns</li>
</ol>
<p>Review<br>Running distributed systems requires cooperation between developers, QA, and operations engineers. Static analysis, and a test suite including example- and property-based tests, can help ensure program correctness, but understanding production behavior requires comprehensive instrumentation and alerting. Mature distributed systems teams often invest in tooling: traffic shadowing, versioning, incremental deploys, and feature flags. Finally, queues require special care.</p>
<hr>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/英语原文/">英语原文</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/分布式/">分布式</a><a href="/tags/架构/">架构</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/04/05/arts-2019-4-5-algorithm/" title="LRU缓存机制" itemprop="url">LRU缓存机制</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-04-05T08:16:07.000Z" itemprop="datePublished"> Published 2019-04-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。<br>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。<br>进阶:<br>你是否可以在 O(1) 时间复杂度内完成这两种操作？<br>示例:<br>LRUCache cache = new LRUCache( 2 /<em> 缓存容量 </em>/ );<br>cache.put(1, 1);<br>cache.put(2, 2);<br>cache.get(1);       // 返回  1<br>cache.put(3, 3);    // 该操作会使得密钥 2 作废<br>cache.get(2);       // 返回 -1 (未找到)<br>cache.put(4, 4);    // 该操作会使得密钥 1 作废<br>cache.get(1);       // 返回 -1 (未找到)<br>cache.get(3);       // 返回  3<br>cache.get(4);       // 返回  4</p>
<p>原题地址 <a href="https://leetcode-cn.com/problems/lru-cache" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lru-cache</a></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>使用linkedhashmap实现，问题在于初始大小小于16，默认会用16，后面的大小是2^n,需要自己控制大小，<br>容量超过最大，需要用迭代取最老的值删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class LRUCache &#123;</span><br><span class="line">    private LinkedHashMap&lt;Integer,Integer&gt; map;</span><br><span class="line">    private int capacity;</span><br><span class="line"></span><br><span class="line">    public LRUCache(int capacity) &#123;</span><br><span class="line">        map = new LinkedHashMap&lt;Integer,Integer&gt;(capacity,0.75f,true);</span><br><span class="line">        this.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int get(int key) &#123;</span><br><span class="line">        Integer value = map.get(key);</span><br><span class="line">        if(value == null)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void put(int key, int value) &#123;</span><br><span class="line">        if(map.containsKey(key))&#123;</span><br><span class="line">            map.remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">        if(map.size() &gt;= capacity)&#123;</span><br><span class="line">            map.remove(map.keySet().iterator().next());</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(key,value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>哈希表+双向链表<br>一个hashmap存储key，快速访问，capacity容量记录大小，一个head，tail指针用于添加和删除。<br>注意点：</p>
<ol>
<li>hashmap是key+Node，不然取不出node。</li>
<li>get方法</li>
</ol>
<ul>
<li>空表处理</li>
<li>存在就删除这个结点，放到head上，要判断head和tail为空的情况</li>
</ul>
<ol start="3">
<li>put</li>
</ol>
<ul>
<li>小于容量，看是否存在，存在删除，直接放在head</li>
<li>等于容量，看是否存在，存在删除，直接放在head</li>
<li>不存在，删除tail，放在head</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">class LRUCache &#123;</span><br><span class="line">    private int capacity;</span><br><span class="line">    private Map&lt;Integer,Node&gt; map;</span><br><span class="line">    private Node head;</span><br><span class="line">    private Node tail;</span><br><span class="line">    </span><br><span class="line">    class Node&#123;</span><br><span class="line">        int key;</span><br><span class="line">        int value;</span><br><span class="line">        Node pre;</span><br><span class="line">        Node next;</span><br><span class="line">        public Node(int key,int value)&#123;</span><br><span class="line">            this.key = key;</span><br><span class="line">            this.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public LRUCache(int capacity) &#123;</span><br><span class="line">        map = new HashMap&lt;Integer,Node&gt;();</span><br><span class="line">        this.capacity = capacity;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">     public int get(int key) &#123;</span><br><span class="line">        //空表处理</span><br><span class="line">        Node node = map.get(key);</span><br><span class="line">        if(node == null)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        //存在就删除这个结点，放到head上，要判断head和tail为空的情况</span><br><span class="line">        removeNode(node);</span><br><span class="line">        insertHead(node);</span><br><span class="line">        return node.value;</span><br><span class="line">    &#125;</span><br><span class="line">     private void removeNode(Node node)&#123;</span><br><span class="line">         //存在就删除这个结点，放到head上，要判断head和tail为空的情况</span><br><span class="line">        Node pre = node.pre;</span><br><span class="line">        Node next = node.next;</span><br><span class="line">      </span><br><span class="line">        if(node == tail &amp;&amp; node == head)&#123;</span><br><span class="line">            head = tail = null;</span><br><span class="line">        &#125;else if(node == tail)&#123;</span><br><span class="line">          </span><br><span class="line">            pre.next = null;</span><br><span class="line">            tail = pre;</span><br><span class="line">            </span><br><span class="line">        &#125;else if(node == head)&#123;</span><br><span class="line">          </span><br><span class="line">            next.pre =  null;</span><br><span class="line">            head = next;</span><br><span class="line">            </span><br><span class="line">        &#125;else&#123;</span><br><span class="line">          </span><br><span class="line">            pre.next = next;</span><br><span class="line">            next.pre = pre;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        map.remove(node.key);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">     private void insertHead(Node node)&#123;</span><br><span class="line">        //插入头部要判断head的空问题</span><br><span class="line">        if(head == null)&#123;</span><br><span class="line">            head = node;</span><br><span class="line">            tail = node;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            Node oldHead = head;</span><br><span class="line">            node.next = oldHead;</span><br><span class="line">            oldHead.pre = node;</span><br><span class="line">            head = node;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(node.key,node);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    private void removeTail()&#123;</span><br><span class="line">        </span><br><span class="line">        if(tail == null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        map.remove(tail.key);</span><br><span class="line">        if(tail.pre == null)&#123;</span><br><span class="line">            tail = head = null;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            tail = tail.pre;</span><br><span class="line">            tail.next = null;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    public void put(int key, int value) &#123;</span><br><span class="line">        Node node = map.get(key);</span><br><span class="line"></span><br><span class="line">        if(map.size() &lt; capacity)&#123;       </span><br><span class="line">            if(node != null)&#123;</span><br><span class="line">                removeNode(node);          </span><br><span class="line">            &#125;</span><br><span class="line">            Node newNode = new Node(key,value);</span><br><span class="line">            insertHead(newNode);</span><br><span class="line">            map.put(key,newNode);</span><br><span class="line">        &#125;else if(map.size() == capacity)&#123;</span><br><span class="line">            if(node != null)&#123;</span><br><span class="line">                removeNode(node);  </span><br><span class="line">                insertHead(new Node(key,value));</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                removeTail();  </span><br><span class="line">                Node newNode = new Node(key,value);</span><br><span class="line">                insertHead(newNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //小于容量，看是否存在，存在删除，直接放在head</span><br><span class="line">        //等于容量，看是否存在，存在删除，直接放在head</span><br><span class="line">        //不存在，删除tail，放在head</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="曾经错误点"><a href="#曾经错误点" class="headerlink" title="曾经错误点"></a>曾经错误点</h3><p>1.头尾都是一个结点删除结点错误</p>
<h3 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h3><p>哈希表，+带前后哨兵的双向链表，为了简化头尾空的判断。思路2的主要容易错的点是头尾空的情况，那是不是可以用哨兵简化判断，都头尾都是空的结点，没有实际值就不会出现判断空值的特殊情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">class LRUCache &#123;</span><br><span class="line">    private int capacity;</span><br><span class="line">    private Map&lt;Integer,Node&gt; map;</span><br><span class="line">    //dummy</span><br><span class="line">    private Node head;</span><br><span class="line">    private Node tail;</span><br><span class="line">    </span><br><span class="line">    class Node&#123;</span><br><span class="line">        int key;</span><br><span class="line">        int value;</span><br><span class="line">        Node pre;</span><br><span class="line">        Node next;</span><br><span class="line">        public Node(int key, int value)&#123;</span><br><span class="line">            this.key = key;</span><br><span class="line">            this.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        public Node()&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public LRUCache(int capacity) &#123;</span><br><span class="line">        this.capacity = capacity;</span><br><span class="line">        map = new HashMap&lt;Integer,Node&gt;();</span><br><span class="line">        head = new Node();</span><br><span class="line">        tail = new Node();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int get(int key) &#123;</span><br><span class="line">        Node node = map.get(key);</span><br><span class="line">        if(node == null)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        insertHeadNode(node);</span><br><span class="line">        return node.value;</span><br><span class="line">    &#125;</span><br><span class="line">     public void put(int key, int value) &#123;</span><br><span class="line">        int size = map.size();</span><br><span class="line">        Node node = map.get(key);</span><br><span class="line">        if(node == null)&#123;</span><br><span class="line">            if(size == capacity)&#123;</span><br><span class="line">                removeTail();</span><br><span class="line">            &#125;         </span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            </span><br><span class="line">            removeNode(node);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        Node newNode = new Node(key,value);</span><br><span class="line">        insertHeadNode(newNode);</span><br><span class="line">    &#125;</span><br><span class="line">    private void removeTail()&#123;</span><br><span class="line">        Node preNode = tail.pre;</span><br><span class="line">      </span><br><span class="line">        if(preNode == head)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Node node = preNode.pre;</span><br><span class="line">        node.next = tail;</span><br><span class="line">        tail.pre = node;</span><br><span class="line">        map.remove(preNode.key);</span><br><span class="line">    &#125;</span><br><span class="line">    private void removeNode(Node node)&#123;</span><br><span class="line">        Node pre = node.pre;</span><br><span class="line">        Node next = node.next;</span><br><span class="line">        map.remove(node.key);</span><br><span class="line">        </span><br><span class="line">        pre.next = next;</span><br><span class="line">        next.pre = pre;</span><br><span class="line">    &#125;</span><br><span class="line">     private void insertHeadNode(Node node)&#123;</span><br><span class="line">        Node oldNext = head.next;</span><br><span class="line">        </span><br><span class="line">        node.next = oldNext;</span><br><span class="line">        head.next = node;</span><br><span class="line">        </span><br><span class="line">        node.pre = head;</span><br><span class="line">        oldNext.pre = node;</span><br><span class="line">        </span><br><span class="line">        map.put(node.key,node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="曾经错误点-1"><a href="#曾经错误点-1" class="headerlink" title="曾经错误点"></a>曾经错误点</h3><p>1.在put方法内，已经存在的值，重新put的时候，出现了错误，这个时候，不管容量是不是达到最大，也都是要删除该结点重新插入。这个很难发现，测试用例是30上的那个发现的，我几乎不能人力复现，测试用例真的很重要，要是我自己构建测试用例，估计很难发现这个问题。这也是我一直缺失的质量问题。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以效仿linkedHashmap去实现，它已经预设了实现lru的方法，使用双线链表方便删除与添加，使用hashmap快速查找是否存储，时间复杂度是O（1），空间复杂度是O（n），双向链表和hash表还是比较耗费空间的，但也在允许范围内。哨兵可以简化头尾的判断，减少空值的情况，但会多耗费2个空间。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/leetcode/">leetcode</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/算法/">算法</a><a href="/tags/哈希表/">哈希表</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/03/31/arts-2019-02-31-review/" title="scalability availability &amp; stability patterns 学习笔记" itemprop="url">scalability availability &amp; stability patterns 学习笔记</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-03-31T10:49:07.000Z" itemprop="datePublished"> Published 2019-03-31</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>原文地址 <a href="https://www.slideshare.net/jboner/scalability-availability-stability-patterns" target="_blank" rel="noopener">https://www.slideshare.net/jboner/scalability-availability-stability-patterns</a></p>
<p>这个ppt总结真的很全面，从可扩展性，可用性，稳定性，3个方面分别讲了达到每个目的，以及有什么手段，什么方法来解决这个问题。<br>没看文章前，我是有一些零碎的概念的，但看了文章后，我突然有一些理解分布式了，架构的目的是达到现实目标，要达到哪方面目的，就用哪些技术。（第一遍读还有很多，不懂的地方，先做一个粗略的总结）</p>
<h2 id="可用性（availability）"><a href="#可用性（availability）" class="headerlink" title="可用性（availability）"></a>可用性（availability）</h2><p>达到可用性，有2种手段，故障转移（Fail-over）和冗余备份（Replication）</p>
<h3 id="Fail-over"><a href="#Fail-over" class="headerlink" title="Fail-over"></a>Fail-over</h3><p>故障转移，表面上看是只要有失败就转移到其他正常的服务上去，然后再回写同步数据。但实际情况要复杂的多，可能出现各种失败的情况。</p>
<h3 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h3><p>备份分为几种：master-slave，tree-replication，master-master，Buddy replication</p>
<p>同步方式：<br>active replication：push<br>passive replication： pull</p>
<h2 id="稳定性（stability）"><a href="#稳定性（stability）" class="headerlink" title="稳定性（stability）"></a>稳定性（stability）</h2><h3 id="Timeouts"><a href="#Timeouts" class="headerlink" title="Timeouts"></a>Timeouts</h3><p>保证每个调用都有超时时间，不会无限期假死。</p>
<h3 id="Circuit-Breaker"><a href="#Circuit-Breaker" class="headerlink" title="Circuit Breaker"></a>Circuit Breaker</h3><p>将失败作为一种正常的状态，而不是维护正常的状态。出现异常，尽早发现，采取其他处理。</p>
<h3 id="Let-it-crash"><a href="#Let-it-crash" class="headerlink" title="Let-it-crash"></a>Let-it-crash</h3><p>如果服务出现异常，不用尽力恢复，尽早发现，及时止损。</p>
<h3 id="Fail-fast"><a href="#Fail-fast" class="headerlink" title="Fail-fast"></a>Fail-fast</h3><p>跟上一个有点像</p>
<h3 id="Bulkheads"><a href="#Bulkheads" class="headerlink" title="Bulkheads"></a>Bulkheads</h3><p>有点像线程池，将一些资源放在一个池子里，与其他进行隔离，即使出问题，也不会导致全局卡死，也保护了资源。</p>
<h3 id="Steady-State"><a href="#Steady-State" class="headerlink" title="Steady State"></a>Steady State</h3><p>清理状态，时刻保持可用。</p>
<h3 id="Throttling"><a href="#Throttling" class="headerlink" title="Throttling"></a>Throttling</h3><p>限流，比如控制请求的数量</p>
<h2 id="可扩展性（scalability）"><a href="#可扩展性（scalability）" class="headerlink" title="可扩展性（scalability）"></a>可扩展性（scalability）</h2><p>可扩展性主要是为了管理过载，分两种内容：状态与行为。<br>状态：分布式缓存，数据网格，服务状态，HTTP缓存，CAP，同步，分区，备份<br>行为：计算网格，事件驱动架构，负载均衡，并行计算</p>
<p>对于可扩展的一般的建议<br><strong>默认不可变<br>引用透明（函数式编程）<br>懒加载<br>考虑数据存储</strong></p>
<h2 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h2><h3 id="性能-vs-可扩展"><a href="#性能-vs-可扩展" class="headerlink" title="性能 vs 可扩展"></a>性能 vs 可扩展</h3><p><strong>如何确定性能问题</strong><br>单用户很慢，<br><strong>如何确定可扩展问题</strong><br>单用户很快，压力大就慢</p>
<h3 id="延迟-vs-吞吐"><a href="#延迟-vs-吞吐" class="headerlink" title="延迟 vs 吞吐"></a>延迟 vs 吞吐</h3><p>最大的吞吐量，加上可接受的延迟</p>
<h3 id="可用性-vs-一致性"><a href="#可用性-vs-一致性" class="headerlink" title="可用性 vs 一致性"></a>可用性 vs 一致性</h3><p><strong>CAP</strong><br>consistency<br>availability<br>Partition<br><strong>ACID</strong><br>Atomic<br>Consistency<br>Isolated<br>Durable</p>
<p>什么时候需要强一致性，什么时候需要最终一致性</p>
<h2 id="Status（状态管理）"><a href="#Status（状态管理）" class="headerlink" title="Status（状态管理）"></a>Status（状态管理）</h2><p>Partitioning，<br>HTTP caching：reverse proxy，cdn，<br>，Data Grids，<br>Service of record:RDBMS sharing，NOSQL(key-value,Column,document,graph,datastructure)<br>Distrbuted caching:write-through,write-behind,eviction policites,replication,peer to peer<br>Concurrency:Shared-state, message-passing,dataflow,software transactional memory</p>
<h2 id="behavior（行为管理）"><a href="#behavior（行为管理）" class="headerlink" title="behavior（行为管理）"></a>behavior（行为管理）</h2><p>Event-Driven Archietecture（<br>Domian events，Event sourcing, command and Query Responsiblity Segregation(CQRS)pattern,<br>Event Stream Processing,Messaging(Publish-Subscribe,Point-to-point,Store-forward,Request-Reply),Enterprice Service Bus ,Actors,Enterprice Integration Architecture(EIA)<br>）<br>Compute Grids<br>Load-balancing<br>Parallel computing</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/英语原文/">英语原文</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/分布式/">分布式</a><a href="/tags/架构/">架构</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/03/31/arts-2019-02-31-tip/" title="Vue 学习笔记1" itemprop="url">Vue 学习笔记1</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="R_Richie" target="_blank" itemprop="author">R_Richie</a>
		
  <p class="article-time">
    <time datetime="2019-03-31T10:45:07.000Z" itemprop="datePublished"> Published 2019-03-31</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>使用一些大而全的框架，可能上手很快，但很快你就陷入出了问题不知所措，一顿搜索解决问题，但还是不明所以的状态。<br>当初学习spring的时候有，现在使用nuxt.js也有，nuxt.js支持后台渲染页面和单页面，也规定了一些项目目录结构，开始还是很娱乐的，轻松启动。但遇到问题，虽然是原生的vue，但找的解决方法还是不能应用，就好像用了假Vue一样，理解原理很重要。<br>就像Vue学习的初期，官方文档也提醒尽量不用cli去创建项目，包括东西太多，很多还是跟打包有关，你既然要学习vue，就应该只学习重点，不然干扰项打扰，不然会影响效果。<br>最近在做页面间的跳转，其实我的需求很简单，就是一个视频网站，点击后能跳到播放和详情页。用了一些vue的跳转没有成功，后面使用了nuxt.js推荐的<nuxt-link> 标签，可以跳转了，而且这个标签还支持传参数。<br>看到编译后的标签，是一个a标签，然后看文档，这个支持前进和后退功能，相当于自己做了一个浏览器的堆栈保存访问的地址。<br>现在还有一个问题，就是我想做 播放页点击其他视频，再重新加载，但由于是同一个页面导致不能加载，还没有方法解决。</nuxt-link></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/前端/">前端</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/vue/">vue</a><a href="/tags/编程技巧/">编程技巧</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/4/"><span></span>Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Java语言基础/" title="Java语言基础">Java语言基础<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Spring/" title="Spring">Spring<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/leetcode/" title="leetcode">leetcode<sup>15</sup></a></li>
		  
		
		  
			<li><a href="/categories/人文/" title="人文">人文<sup>15</sup></a></li>
		  
		
		  
			<li><a href="/categories/前端/" title="前端">前端<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/后端/" title="后端">后端<sup>13</sup></a></li>
		  
		
		  
			<li><a href="/categories/成长/" title="成长">成长<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/树莓派/" title="树莓派">树莓派<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/监控/" title="监控">监控<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/英语原文/" title="英语原文">英语原文<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/闲谈/" title="闲谈">闲谈<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/编程技巧/" title="编程技巧">编程技巧<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/感悟/" title="感悟">感悟<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/算法/" title="算法">算法<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/java/" title="java">java<sup>13</sup></a></li>
			
		
			
				<li><a href="/tags/分布式/" title="分布式">分布式<sup>12</sup></a></li>
			
		
			
				<li><a href="/tags/架构/" title="架构">架构<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/纪录片/" title="纪录片">纪录片<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/链表/" title="链表">链表<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/集合/" title="集合">集合<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/并发集合/" title="并发集合">并发集合<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/历史/" title="历史">历史<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Java/" title="Java">Java<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Trie树/" title="Trie树">Trie树<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/vue/" title="vue">vue<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/spring-cloud/" title="spring cloud">spring cloud<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/吴军/" title="吴军">吴军<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/图/" title="图">图<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/二分查找/" title="二分查找">二分查找<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/锁/" title="锁">锁<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/二叉树/" title="二叉树">二叉树<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Larry Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2019 
		
		<a href="/about" target="_blank" title="R_Richie">R_Richie</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
